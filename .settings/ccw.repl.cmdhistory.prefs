cmdhistory=["(doc source)" "(source map)" "(source reduce)" "(source r/reduce)" "(source coll-reduce)" "(doc conj\!)" "(source conj\!)" "CollReduce" "(time (count (fmap identity t)))" "p" "(take 10 (fmap identity (iterate inc 0)))" "(doc clojure.lang.IEditableCollection)" "(doc transient)" "(transient (seq [1]))" "(transient [5])" "(transient '(5))" "(take 10 (fmap identity (iterate inc 0)))" "*ns*" "(doc fmap)" "(take 10 (fmap identity (iterate inc 0)))" "(take 10 (fmap identity (vec (iterate inc 0))))" "(take 10 (fmap identity (iterate inc 0)))" "(take 10 (fmap (iterate inc 0) identity))" "(take 10 (r/map identity (iterate inc 0)))" "(take 10 (seq (fmap (iterate inc 0) identity)))" "(take 10 (seq (r/map identity (iterate inc 0))))" "(take 10 (into [] (r/map identity (iterate inc 0))))" "(take 10 (fmap identity (iterate inc 0)))" "(count (fmap identity (iterate inc 0)))" "(take 10 (fmap identity t))" "(take 10 (iterate inc 0))" "(lazy-seq [1 2])" "(fmap identity (lazy-seq [1 2]))" "(type (lazy-seq [1 2]))" "(isa? (lazy-seq [1 2]) clojure.lang.IPersistentCollection)" "(empty (lazy-seq [1 2]))" "(into (empty []) (map inc  (lazy-seq [1 2])))" "(fmap identity (lazy-seq [1 2]))" "(fmap identity [1 2])" "(fmap identity '(1 2))" "(fmap identity \#(1 2))" "(fmap identity \#{1 2})" "(r/map identity \#{1 2})" "(r/map identity [1 2])" "(doc r/fold)" "(fold conj (r/map inc [1 2]))" "(r/fold conj (r/map inc [1 2]))" "(r/fold conj [] (r/map inc [1 2]))" "(r/fold + (r/map inc [1 2]))" "(source r/fold)" "(r/fold conj [] (r/map inc [1 2]))" "(r/fold [] conj (r/map inc [1 2]))" "(r/fold conj conj (r/map inc [1 2]))" "(doc r/monoid)" "(source r/monoid)" "(empty (lazy-seq [1 2]))" "(fmap inc [1 2])" "(fmap inc (seq [1 2]))" "(fmap inc (seq '(1 2)))" "(map inc (seq '(1 2)))" "(fmap inc (lazy-seq '(1 2)))" "(fmap inc (lazy-seq [1 2]))" "(fmap inc \#{1 2})" "(fmap inc (lazy-seq \#{1 2}))" "(r/map inc \#{1 2})" "(conj \#{} (first (r/map inc \#{1 2})))" "((first (r/map inc \#{1 2}))" "(first (r/map inc \#{1 2})" "(first (r/map inc \#{1 2}))" "(into \#{} (r/map inc \#{1 2}))" "(source into)" "(reduce conj \#{} (r/map inc \#{1 2}))" "(r/reduce conj \#{} (r/map inc \#{1 2}))" "(r/reduce conj (empty \#{}) (r/map inc \#{1 2}))" "(fmap inc \#{1 2})" "(p/fmap inc \#{1 2})" "(p/fmap \#{1 2} inc)" "(p/fmap inc \#{1 2})" "(fmap inc \#{1 2})" "(doc r/map)" "(fmap inc \#{1 2})" "(fmap inc {1 2})" "(fmap identity {1 2})" "(fmap identity (lazy-seq [1 2]))" ";; Switching to org.uncomplicate.redcat namespace" "(fmap identity (lazy-seq [1 2]))" "(doc for)" "(source for)" "(doc mapcat)" "(doc conj)" "(time (count (map \#(conj (empty []) %) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(vec %) (take 1000000 (iterate inc 0))\\n                  )))" "(vec 1)" "(vetor 1)" "(time (count (map \#([%]) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(vec %) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(vec [%]) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map vec (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map list (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(conj (empty (list)) %) (take 1000000 (iterate inc 0))\\n                  )))" "(time [])" "(time (empty []))" "(source mapcat)" "(doc r/map)" "r/map" "(defn incm [x] [(inc x)])" "(incm 1)" "(mapcat incm [1])" "(mapcat incm [1 2 3])" "(map incm [1 2 3])" "  (require '[clojure.core.reducers \:as r])" "(into [] (r/map incm [1 2 3]))" "(source concat)" "(find-doc conj)" "(find-doc \\"conj\\")" "(find-var \\"conj\\")" "(find-var \\n  conj)" "(find-var 'conj)" "(doc find-var)" "(into [1 2] [3 4])" "(concat [1 2] [3 4])" "(reduce into (r/map incm [1 2 3]))" "(reduce into [] (r/map incm [1 2 3]))" "(bind [1 2 3] incm)" "bind" ">>\=" "(p/bind [1 2 3] incm)" "(r/reduce into (r/map incm [1 2 3]))" "(p/bind [1 2 3] incm)" "(r/reduce into [] (r/map incm [1 2 3]))" "(apply concat [[1] [2] [3]])" "(source concat)" "(join [(list 1 2) (list 3 4)])" "(r/join [(list 1 2) (list 3 4)])" "(p/join [(list 1 2) (list 3 4)])" "(p/join [[1 2] [3 4]])" "(p/bind sum [[1 2] [3 4]])" "(p/bind incm [[1 2] [3 4]])" "(p/bind [[1 2] [3 4]] incm)" "(p/bind [1 2 3 4] incm)" "(p/join [[1 2] [3 4]])" "(p/reduce into [[1 2] [3 4]])" "(reduce into [[1 2] [3 4]])" "(r/reduce into [[1 2] [3 4]])" "(r/reduce into []\\n          [[1 2] [3 4]])" "(p/join [[1 2] [3 4]])" "(reduce into [[1 2] [3 4]])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "join" "(join [[1 2] [3 4]])" "(defn incm [x] [(inc x)])" "(bind [[1 2] [3 4]] incm)" "(join [[1 2] [3 4]])" "(bind [[1 2] [3 4]] incm)" "(bind [[2] [4]] incm)" "r" "r/cat" "(r/map [[2] [4]] incm)" "(first \\n  (r/map [[2] [4]] incm))" "(bind [2 4] incm)" "(r/map incm [2 4])" "(first (r/map incm [2 4]))" "(count (r/map incm [2 4]))" "(reduce into (r/map incm [2 4]))" "(reduce into [] (r/map incm [2 4]))" "(r/reduce into [] (r/map incm [2 4]))" "(reduce into [[2] [4]])" "(join '([1 2] [3 4]))" "(join '([1 2] (3 4)))" "(join '([1 2] {3 4}))" "(first (r/map inc [1 2]))" "(bind [2 4] incm)" "(r/reduce into [[1 2] [3]])" "(doc r/reduce)" "(into)" "(fmap [2 4] incm)" "(bind [2 4] incm)" "(bind \#{2 4} incm)" "(fmap \#{2 4} inc)" "(bind \#{2 4} incm)" "(join '([1 2] {3 4}))" "(fmap \#{2 4} inc)" "(fmap \#(fmap \#{2 16} %) [inc exp])" "(fmap \#(fmap \#{2 16} %) [inc (partial * 100)\\n                         ])" "(fmap [inc (partial * 100)] \#(fmap \#{2 16} %))" "(<*> [inc (partial * 100)] [1 2])" "(doc for)" "(r/map [inc (partial * 100)] \#(r/map \#{2 16} %))" "(join (r/map [inc (partial * 100)] \#(r/map \#{2 16} %)))" "(r/reduce into [] (r/map [inc (partial * 100)] \#(r/map \#{2 16} %)))" "(into [] (r/map [inc (partial * 100)] \#(r/map \#{2 16} %)))" "(fmap [inc (partial * 100)] \#(fmap \#{2 16} %))" "(join (fmap [inc (partial * 100)] \#(fmap \#{2 16} %)))" "(<*> [inc (partial * 100)] [1 2])" "(bind [1 2] [inc (partial * 100)])" "(bind [inc (partial * 100)] \#(fmap [1 2] %))" "(source apply)" "(<*> [inc (partial * 100)] [1 2])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(<*> [inc (partial * 100)] [1 2])" "(doc lazy-seq)" "(doc ralized?)" "(fmap (lazy-seq [1 2] inc))" "(fmap (lazy-seq [1 2]) inc))" "(r/map (lazy-seq [1 2]) inc)" "(lazy-seq (r/map (lazy-seq [1 2]) inc))" "(empty (lazy-seq [1 2]))" "(doc lazy-seq)" "(isa? (seq [1]) clojure.lang.LazySeq)" "(isa? (map identity (seq [1])) clojure.lang.LazySeq)" "(doc map)" "(instance? (map identity (seq [1])) clojure.lang.LazySeq)" "(instance? (map identity (seq [1])) clojure.lang.LazySeq.class)" "(type (map identity (seq [1])))" "(isa? clojure.lang.LazySeq clojure.lang.LazySeq)" "(isa? (type (map identity (seq [1]))) clojure.lang.LazySeq)" "(isa? (seq [1])) clojure.lang.LazySeq)" "(isa? (type (seq [1])) clojure.lang.LazySeq)" "(doc seq)" "(doc lazy-seq)" "(lazy-seq [1])" "(bind (lazy-seq [inc (partial * 100)]) \#(fmap [1 2] %))" "(wrap (lazy-seq []) 1)" "(type (wrap (lazy-seq []) 1))" "(source concat)" "(\= [1 2] [2 1])" "(id [ 1 2])" "id" "(id [ 1 2])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(id [ 1 2])" "(concat nil [1])" "(next [])" "(concat (seq [1]) nil)" "(into [1] nil)" "(into nil [1])" "(+ 1 nil)" "(doc r/fold)" "(fold + [1 2])" "(r/fold + [1 2])" "(r/fold plus [[1] [2]])" "(r/fold (monoid plus) [[1] [2]])" "(r/fold (r/monoid plus) [[1] [2]])" "(doc r/monoid)" "(r/fold (r/monoid plus []) [[1] [2]])" "(r/fold (r/monoid plus list) [[1] [2]])" "(r/fold (r/monoid plus vec) [[1] [2]])" "(doc [])" "(r/fold (r/monoid plus vector) [[1] [2]])" "(r/fold (r/monoid plus id) [[1] [2]])" "(r/fold (r/monoid + 0) [[1] [2]])" "(r/fold (r/monoid + 0) [1 2])" "(doc r/monoid)" "(vector)" "(r/fold (r/monoid plus (partial id [])) [[1] [2]])" "(first [])" "([] 0)" "(fold [[1] [2]])" "(doc op)" "(const 1)" "((constantly 1) 9)" "(opf [])" "(fold (opf []) [[1 2] [3 4]])" "(r/fold (opf []) [[1 2] [3 4]])" "(fold [[1 2] [3 4]])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(fold [[1 2] [3 4]])" "(doc +)" "(+ 1/2 1/3)" "(fold [1 2 3])" "(fold [1 2 3/3])" "(fold [1 2 2/3])" "(foldmap [1 2 2/3] (op-fun 1 *))" "(fold [1 2 2/3])" "(fold [1 2 2/3 9.99])" "(fold [1.0000000000000000000000000000000000001 2 2/3 9.99])" "(doc r/monoid)" "(fmap (atom 1) inc)" "(def a (atom 1))" "(fmap a inc)" "a" "(def r (ref 1))" "(fmap r inc)" "(do-sync (fmap r inc))" "(dosync (fmap r inc))" "r" "(atom)" "(atom nil)" "(<*> (atom inc) (atom 1))" "(join [[1 2] [3 4]])" "(join (atom (atom 1)))" "(atom (atom 1))" "(join (atom (atom 1)))" "a" "(def ma (atom a))" "ma" "(join ma)" "ma" "(bind (atom 1) \#(atom (inc %)))" "(fmap (atom 1) \#(atom (inc %)))" "(join [1 2])" "(bind [1 2] \#(vector (inc %)))" "(fmap [1 2] \#(vector (inc %)))" "(fmap (atom 1) \#(atom (inc %)))" "(swap\! (atom 1) \#(atom (inc %)))" "(swap\! (atom 1) inc)" "(set\! (atom 1) 2)" "(doc set\!)" "(fmap (atom 1) \#(atom (inc %)))" "(<*> (atom inc) (atom 1))" "(join (atom (atom 1)))" "(bind (atom 1) \#(atom (inc %)))" "(bind (ref 1) \#(atom (inc %)))" "(dosync (bind (ref 1) \#(atom (inc %))))" ";; Switching to org.uncomplicate.redcat namespace" "(fmap [1 2 3] inc)" "(fmap inc [1 2 3])" "((fmap inc) [1 2 3])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(doc r/map)" "(source r/map)" "(source map)" "((fmap inc) [1 2 3])" ";; Switching to org.uncomplicate.redcat.core namespace" "((fmap inc) [1 2 3])" "(doc reverse)" "(reverse \\"abc\\")" "(doc str)" "(doc l (iterate inc 1000000))" "(def l (iterate inc 1000000))" "(str [1 2 3])" "(apply str [1 2 3])" "(def s (apply str l))" "1" "(empty \\"a\\")" "(into (empty \\"a\\") \\"abc\\")" "(fmap reverse \\"abc\\")" "(fmap reverse (seq \\"abc\\"))" "(fmap reverse \\"abc\\")" "(reverse \\"abc\\")" "(time (reverse \\"abc\\"))" "(time (fmap reverse \\"abc\\"))" "(time (reverse \\"abc\\"))" "(time (fmap reverse \\"abc\\"))" "(time (fmap (comp reverse reverse) \\"abc\\"))" "(fmap inc dec)" "((fmap inc dec) 1)" "(source map)" "(doc map)" "(doc str)" "(doc ->)" "(doc protocol)" "(doc defprotocol)" "(fmap inc 1 2 3)" "(fmap inc [1 2 3])" "(str 1)" "(fmap str [1 2 3])" "(doc fmap)" "((fmap str inc) 1)" "((fmap str dec) 1)" "((fmap dec str) 1)" "((comp dec str) 1)" "((comp str dec) 1)" "((fmap str inc) 1)" "((fmap (partial * 3) (partial + 100) 1)" "((fmap (partial * 3) (partial + 100)) 1)" "((fmap str) 1)" "((fmap str) [1])" "((fmap str) [1 2 3])" "(doc fold)" "(doc fmap)" "(fmap identity [1 2 3])" "(\= identity (fmap identity))" "(\= identity identity)" "(fmap inc 1)" "(and (function? inc) inc)" "(and (fn? inc) inc)" "(\= (and (fn? inc) inc) inc)" "(or 1 2)" "(fmap identity [1 2 3])" "(fmap identity nil)" "(\= (atom 1) (atom 1))" "(def a (atom 1))" "(seq [2 3 4])" "(\= [1] (seq [1]))" "(\=\= [1] (seq [1]))" "(seq? [1])" "(for [a [1 2 3]] (inc a))" "(doc for)" "1" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(gen/long)" "gen" ";; Switching to org.uncomplicate.redcat.core-test namespace" "gen" "(gen/long)" "(defspec [^int seed ^{\:tag (uniform 1 100)} iters])" "(gen/defspec [^int seed ^{\:tag (uniform 1 100)} iters])" "(gen/defspec ^int seed ^{\:tag (uniform 1 100)} iters)" "(defspec longs-are-closed-under-increment\\n  inc ;; function under test\\n  [^long l]  ;; indicates generation via gen/long\\n  (assert (instance? Long %)))" "(gen/defspec longs-are-closed-under-increment\\n  inc ;; function under test\\n  [^long l]  ;; indicates generation via gen/long\\n  (assert (instance? Long %)))" "(longs-are-closed-under-increment 4)" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(gen/)" "(gen/vec gen/anything)" "(gen/vec gen/boolean)" "(gen/vec gen/int)" "(gen/one-of inc dec)" "(gen/one-of [inc dec])" "((gen/one-of [inc dec]))" "(gen/oneof 1 2)" "(gen/one-of 1 2)" "p" "(gen/oneof 1 2)" "(gen/one-of 1 2)" "*num-trials*" "(require '[midje.ideas.formulas \:as ideas])" "ideas/*num-trials*" "(gen/one-of inc dec)" "(gen/one-of 1 2)" "(gen/one-of 1 2 3)" "(gen/one-of 1 2 \:d)" "(gen/one-of 1 2 inc)" "inc" "(gen/one-of 1 2 [\\n                 inc])" "(gen/one-of 1 2 inc)" "((gen/one-of dec inc) 1)" "((gen/one-of 'dec 'inc) 1)" "(doc gen/one-of)" "(source gen/one-oof)" "(source gen/one-o\\n        f)" "(source gen/one-of)" "[inc dec]" "(gen/one-of inc)" "(doc formula)" "(source formula)" "(macroexpand (functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(macroexpand '(functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(formula [f1 (first (gen/one-of [inc] [dec] [(partial * 100)]))\\n          f2  (first (gen/one-of [inc] [dec] [(partial * 100)]))\\n          x (gen/int)]\\n              (fmap (comp f1 f2) x) \=> (fmap f1 (fmap f2 x)))" "(macroexpand '(functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(doc gen/int)" "(def args [inc (partial * 100)])" "(gen/one-of args)" "(apply gen/one-of args)" "((apply gen/one-of args) 1)" "((apply gen/one-of inc dec) 1)" "((gen/one-of inc dec) 1)" "((gen/one-of [inc] [dec]) 1)" "(gen/one-of [inc] [dec])" "args" "(apply gen/one-of args)" "(apply gen/one-of '([inc] [dec]))" "args" "(def args '(inc dec))" "(apply gen/one-of args)" "args" "(gen/one-of inc dec)" "(apply gen/one-of '(inc dec))" "(defn gen-fn [&fs]\\n  (first (apply gen/one-of (map vector fs))))" "(defn gen-fn [fs]\\n  (first (apply gen/one-of (map vector fs))))" "(defn gen-fn [&fs]\\n  (first (apply gen/one-of (map vector ~fs))))" "(doc gen/vec)" "(doc isa?)" "(doc formula)" "((comp inc val) (first {\:a 1}))" "(fmap (comp inc val) {\:a 1})" "(type (first {\:a 1}))" "(into {} (type (first {\:a 1})))" "(into {} (first {\:a 1}))" "\\n(first {\:a 1}))" "(into {} [\:a \:b])" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(fmap inc \#(clojure.lang.MapEntry (gen/keyword) (gen/int))" "(fmap inc \#(clojure.lang.MapEntry (gen/keyword) (gen/int)))" "(type (fmap inc (clojure.lang.MapEntry (gen/keyword) (gen/int))))" "(type (fmap inc (clojure.lang.MapEntry. (gen/keyword) (gen/int))))" "10000000000000000000000000000000000000000" "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000*100" "(* 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 100000)" "(+ 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(unsigned-+ 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(unchecked-add 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(doc unchecked-add)" "(find \\"lazy\\")" "(doc find)" "(doc-find \\"lazy)" "(doc-find \\"lazy\\")" "(find-doc \\"lazy\\")" "(fmap inc (seq [1]))" "(type (fmap inc (seq [1])))" "(type (seq [1]))" "(sourc seq)" "(source seq)" "(reverse \\"aaaabbb\\")" "(map reverse str)" "(map reverse \\"ab\\")" "(map char? \\"aa\\")" "(fmap char? \\"aa\\")" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(fmap inc {\:a 1})" "(fmap (fmap inc) {\:a 1})" "(fmap (fmap inc) {2 1})" "(fmap key {1 2})" "(fmap key {\:a \:b})" "(key (first {\:a \:b}))" "(fmap key (first {\:a \:b}))" "\\n*ns*" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap key (first {\:a \:b}))" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap key (first {\:a \:b}))" "(fmap type (first {\:a \:b}))" "(fmap type {\:a \:b})" "(map type {\:a \:b})" "(map type {\:a \:b \:c \:d})" "(fmap type {\:a \:b \:c \:d})" "(r/map type {\:a \:b \:c \:d})" "(require '[clojure.core.reducers \:as r])" "(r/map type {\:a \:b \:c \:d})" "(into {} (r/map type {\:a \:b \:c \:d}))" "(into {} (r/map (fmap type) {\:a \:b \:c \:d}))" "(fmap type (first {\:a \:b}))" "(fmap (fmap type) {\:a \:b})" "(fmap + [1 2 3])" "(pure [] +)" "(fmap inc [1 2 3])" "(fmap and)" "(&& true false)" "(\= false true)" "(\= false)" "(fmap \= [false true])" "(<*> [inc] [1 2 3])" "(ap [inc] [1 2 3])" "(doc r/map)" "(source map)" "(r/map + [1 2 3])" "(into [] (r/map + [1 2 3]))" "(into [] (r/map + [1 2 3] [4 5 6]))" "(time (count (take 1000000 (map inc (iterate inc 0)))))" "(time (count (take 1000000 (fmap inc (iterate inc 0)))))" "(def v (vec (take 1000000 (iterate inc 1000000))))" "(def s (seq (take 1000000 (iterate inc 1000000))))" "(count s)" "(time (count (take 1000000 s)))" "(time (count (take 1000000 v)))" "(time (count v))" "(time (count s))" "(time (last s))" "(time (last v))" "p" "(time (last v))" "(time (first v))" "(type v)" "(time (count (fmap inc v)))" "(time (count (fmap inc s)))" "(time (count (map inc s)))" "(time (count (fmap inc s)))" "(time (count (take 100000000 v)))" "(def v (vec (take 1000000 (iterate inc 100000000))))" "(def v (vec (take 100000000 (iterate inc 1))))" "(def v (vec (take 10000000 (iterate inc 1))))" "(def s (seq (take 10000000 (iterate inc 1))))" "(count s)" ";; Switching to org.uncomplicate.redcat.core namespace" "(ap [inc (partial * 100)] [1 10 50])" "(use 'org.uncomplicate.redcat.jvm)" "(ap [inc (partial * 100)] [1 10 50])" "(<*> [inc (partial * 100)] [1 10 50])" "(fmap inc [1 10 50])" "(fmap [inc] [1 10 50])" "(ap [inc] [1 10 50])" "(join [[1] [2]])" "(p/join [[1] [2]])" "(p/<*> [inc] [1 10 50])" "(ap [inc] [1 10 50])" "(p/<*> [inc] [1 10 50])" "(ap [inc] [1 10 50])" "(ap [inc (partial * 100)] [1 10 50])" "(doc r/map)" "(source r/map)" "r/map" "(require '[clojure.core.reducers \:as r])" "(doc r/map)" "(source r/map)" "(r/mapcat [[1] [2] [3]])" "(into [] (r/mapcat [[1] [2] [3]]))" "(into [] (r/mapcat inc [[1] [2] [3]]))" "(into [] (r/mapcat \#([inc %]) [[1] [2] [3]]))" "(into [] (r/mapcat \#([inc %]) [1 2 3]))" "(doc r/mapcat)" "(doc mapcat)" "(into [] (r/mapcat \#(vec (inc %)) [1 2 3]))" "(mapcat \#(vec (inc %)) [\\n                        1 2 3]))" "(map \#(vec (inc %)) [1 2 3]))" "(map inc [1 2 3])" "(into [] (r/mapcat \#(vector (inc %)) [1 2 3]))" "(source r/mapcat)" "(doc folder)" "(doc r/folder)" "(r/folder (r/mapcat \#(vector (inc %)) [1 2 3]))" "(r/folder [1 2 3] (r/mapcat \#(vector (inc %))))" "(doc r/map)" "(source r/map)" "(source r/mapcat)" "(def v (vec (take 1000000 (iterate inc 0))))" "(defn f [x] (vector (inc x)))" "(time (count (bind f v)))" "(time (count (>>\= f v)))" "(time (count (>>\= [f] v)))" "(time (count (>>\= [inc] v)))" "(p/bind [inc] [1 2 3])" "(time (count (>>\= v [inc])))" "(time (count (>>\= v f)))" "(f 1)" "(time (count (r/mapcat f v)))" "(time (count (into [] (r/mapcat f v))))" "(def v1 (bind v f))" "(def v1 (p/bind v f))" "(time (count (join v1)))" "(time (count (p/join v1)))" "(first v1)" "(def v1 (fmap f v))" "(time (count (p/join v1)))" "(time (count (into [] (r/mapcat identity v1))))" "(time (count (p/join v1)))" "(time (take 10 (p/join v1)))" "(source r/mapcat)" "(time (count (p/join v1)))" "(time (count (flatten v1)))" "(time (count (r/flatten v1)))" "(first v1)" "(time (count (r/foldcat v1)))" "(append\! v1 [\:d])" "(r/append\! v1 [\:d])" "(r/flatten [[1] [2]])" "(into [] (r/flatten [[1] [2]]))" "(time (count (into [] (r/flatten v1))))" "(time (count (p/join v1)))" "(flatten v1)" "(time (count (flatten v1)))" "(time (count (into [] (r/mapcat f v))))" "(time (count (into [] (p/bind v f))))" "(time (count (p/bind v f)))" "(time (count (join v f)))" "(time (count (join f v)))" "(time (count (p/join f v)))" "(time (count (p/join v)))" "(first v)" "v" "(first v)" "(first v1)" "(time (count (p/join v1)))" "(time (count (into [] (r/mapcat f v1))))" "(f 1)" "(time (count (into [] (r/mapcat f v))))" "(time (count (p/join v1)))" "(time (count (into [] (r/mapcat f v))))" "(time (count (p/join v1)))" "(time (count (p/bind v1 f)))" "(f 1)" "(fmap [1 2] f)" "(p/fmap [1 2] f)" "(time (count (p/bind v f)))" "(time (count (p/fmap v f)))" "(time (count (p/bind v f)))" "(into [] (r/mapcat \#(r/map % [1 2 3]) [inc (partial * 100)]))" "(time (count (into [] (r/mapcat \#(r/map % v) [inc (partial * 100)]))))" "(time (count (<*> [inc (partial * 100)] v))))" "(time (count (p/<*> [inc (partial * 100)] v))))" "(time (count (p/<*> [inc (partial * 100)] v)))" "(time (count (into [] (r/mapcat \#(r/map % v) [inc (partial * 100)]))))" "(time (count (p/<*> [inc (partial * 100)] v)))" "p" "(time (count (p/<*> [inc (partial * 100)] v)))" "(time (count (into [] (r/reduce conj (r/reduce conj \#( % v) [inc (partial * 100)]))))" "(doc r/reduce)" "(map \#(%1 %2) [inc] [1 2])" "(time (count (map \#(%1 %2) [inc] v)))" "(time (count (map \#(%2 %1) v [inc])))" "(doc reduce)" "(doc r/mapcat)" "(foldmap [1 2] inc)" "(p/foldmap [1 2] inc)" "(r/map [1 2] inc)" "(into [] (r/map [1 2] inc))" "(p/foldmap [1 2] inc)" "(r/map [1 2] inc)" "(doc r/map)" "(r/map inc [1 2])" "(into [] (r/map inc [1 2]))" "(r/fold (into [] (r/map inc [1 2])))" "(fold (into [] (r/map inc [1 2])))" "(fold (r/map inc [1 2]))" "(doc extend)" "(doc defprotocol)" "(find-doc \\"alias\\")" "(pure [] 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "(pure [] 1)" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(pure [] 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "(pure 1 [])" "pure" "(pure 1 1)" "(pure [1] 1)" "(p/pure [1] 1)" "(def pure1 p/pure)" "(pure1 [1] 1)" "(pure1 [] 1)" "(pure [] 1)" "(pure 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "pure" "(def pure p/pure)" "(pure [] 1)" "(doc mapcat)" "*ns*" "(<*> (pure (lazy-seq [1]) inc) (lazy-seq [1 2 3]))" "(<*> (pure [1] inc) [1 2 3])" "(<*> inc (partial * 100))" "(doc butlast)" ";; Switching to clojure.core.reducers namespace" "(defcurried myfn \\"\\" {} [x y] (+ x y))" "myfn" "(myfn 1 2)" "(myfn 1)" "((myfn 1) 2)" "(macroexpand '(defcurried myfn \\"\\" {} [x y] (+ x y)))" "(macroexpand '(defcurried myfn \\"\\" {} [x y z] (+ x y)))" "(defcurried myfn \\"\\" {} [x y z] (+ x y z))" "(myfn 1)" "(+ 3 nil)" "(<*> [+] [3])" ";; Switching to org.uncomplicate.redcat.core namespace" "(<*> [+] [3])" "((<*> [+] [3]) [4])" "(<*> [+] (<*> [+] [3]) [4])" "(concat [1 2] [3 4])" "(<*> [concat] [1 2] [3 4])" "(source map)" ";; Switching to org.uncomplicate.redcat.core namespace" "(defn ex [x y & zs] (+ x y @zs))" "(ex 1 2 3)" "(defn ex [x y & zs] (apply + x y zs))" "(ex 1 2 3)" "(ex 1 2 3 4)" "(ex 1 2 3 4 5)" "(<*> + nil 1 2 3)" "(<*> + nil 1)" "(<*> + nil\\n     )" "(<*> + nil 1)" "(<*> + nil\\n     \\n     )" "(<*> + nil 1)" "(<*> + nil 1 2 3)" "(time (count (<*> [+] (vec (take 1000000 (iterate inc 0))) (vec (take 1000000 (iterate inc 0))))))" "(time (count (<*> [+] (vec (take 1000000 (iterate inc 0))))))" "(<*> [inc] [1 2 3])" "(partial inc)" "(partial inc 1)" "((partial inc 1))" "(fmap + [1 2] '(3 4))" "(fmap + [1 2] '(3 4 5))" "(fmap + (fmap + [3 4]))" "(fmap (comp + *) [3 4] [5 6 7])" "(fmap + (fmap * [3 4] [5 6 7])" "(fmap + (fmap * [3 4] [5 6 7]))" "(fmap inc (fmap * [3 4] [5 6 7]))" "(fmap (comp inc *) [3 4] [5 6 7]))" "(fmap (comp inc *) [3 4] [5 6 7])" "(inc 1 2)" "(fmap + [1 2] [10 20])" "(<*> [+] [1 2] [10 20])" "(<*> [+ \= * /] [1 2] [10 20])" "(<*> [+ - * /] [1 2] [10 20])" "(count (r/map inc (take 100000000 (iterate inc 1))))" "*ns*" "(require '[clojure.core.reducers \:as r]))" "(count (r/map inc (take 100000000 (iterate inc 1))))" "(count (into [] (r/map inc (take 100000000 (iterate inc 1)))))" "(source vec)" "(fmap partial *)" "(<*> ((fmap partial *) [2 5 10]) [8 10 11])" "(<*> ((fmap (comp partial *)) [2 5 10]) [8 10 11])" "(comp partial *)" "(<*> [inc dec *] [1 2 3] [4 5 6])" "(map + {\:a 1 \:b 2} {\:c 3 \:d 4})" "(map vector {\:a 1 \:b 2} {\:c 3 \:d 4})" "(fmap + {\:a 1 \:b 2} {\:c 3 \:d 4})" "(fmap + {\:a 1 \:b 2})" "(fmap inc {\:a 1 \:b 2})" "(fmap inc [1 2])" "(fmap inc {\:a 1 \:b 2})" "(fmap inc (first {\:a 1 \:b 2}))" "(fmap \#(fmap inc) (first {\:a 1 \:b 2}))" "(fmap (fmap inc) (first {\:a 1 \:b 2}))" "(fmap (fmap inc) {\:a 1 \:b 2})" "(fmap (fmap inc) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap +)" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2})" "(apply fmap + {\:a 1 \:b 2})" "(fmap inc {\:a 1 \:b 2})" "(fmap inc (first {\:a 1 \:b 2}))" "(fmap inc (first {\:a 1 \:b 2}) [3 4])" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "((fmap +) 1 2)" "((fmap inc) 1)" "((fmap +) 1 2)" "(fmap + 1 2)" "((fmap +) 1 2)" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) [[1] [2]] [[3] [5]])" "(map + {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap + {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap \#(+ (val %1) (val % 2)) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap \#(+ (val %1) (val %2)) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(map (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "((fmap +) (first {\:a 1 \:b 2}) (first {\:c 3 \:d 5}))" "(first {\:a 1 \:b 2})" "(apply + 1)" "((fmap +) (first {\:a 1 \:b 2}) (first {\:c 3 \:d 5}))" "(map (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(+ nil 3)" "(fmap + nil 3)" "(source +)" "(source cast)" "(doc reduce1)" "(extend-type +\\n  Functor\\n  (fmap [f x y] f x y))" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(extend-type +\\n  Functor\\n  (fmap [f x y] f x y))" "(type +)" "(extend-type clojure.core$_PLUS_\\n  Functor\\n  (fmap [f x y] f x y))" "(+ 1 2)" "(and 1 nil 2)" "(if (some nil? [1 2 3]) nil \:a)" "(if (some nil? [1 2 nil]) nil \:a)" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap + 1 2)" "(fmap + 1 nil)" "(+ 1 nil)" ";; Switching to org.uncomplicate.redcat.core namespace" "(require 'org.uncomplicate.redcat.jvm)" "  (require '[clojure.core.reducers \:as r])" "(doc r/fold)" "(r/fold + [1 2 3])" "(def v (vec (take 1000000 (iterate inc 0))))" "(time (r/reduce + v))" "(time (r/fold + v))" "(r/fold + v)" "  (require '[clojure.core.reducers \:as r] \:reload)" "(r/fold + v)" "(source require)" "(source loadf-libs)" "(source load-libs)" "(doc load-file)" "(load-file \\"clojure.core.reducers.clj\\")" "(load-file \\"clojure/core/reducers.clj\\")" "*ns*" "(doc name)" "(load-file \\"../clojure/core/reducers.clj\\")" "(load-file \\"./clojure/core/reducers.clj\\")" "(load-file \\"core.clj\\")" "\\n  (import 'java.io.File)" "\\n(defn my-ls [d]\\n  (println \\"Files in \\" (.getName d))\\n  (doseq [f (.listFiles d)]\\n    (if (.isDirectory f)\\n      (print \\"d \\")\\n      (print \\"- \\"))\\n    (println (.getName f))))" "(my-ls (File. \\".\\"))" "  (require '[clojure.core.reducers \:as r] \:reload-all)" "(r/fold + v)" ";; Switching to org.uncomplicate.redcat.core namespace" "  (require '[clojure.core.reducers \:as r])" "(r/fold + v)" "(def v (vec (take 1000000 (iterate inc 0))))" "(time (r/reduce + v))" "(time (r/fold + v))" "(def v (vec (take 10000000 (iterate inc 0))))" "(time (r/fold + v))" "(time (r/reduce + v))" "(time (r/fold + v))" "(time (r/reduce + v))" "(time (count (fmap inc v)))" "(time (count (fmap inc (fmap dec v))))" "(time (count (fmap inc v)))" "(time (count (fmap (comp inc dec) v)))" "(time (count (fmap inc (fmap dec v))))" "(time (count (comp (fmap inc) (fmap dec)) v))" "(time (count ((comp (fmap inc) (fmap dec)) v)))" "((fmap inc dec inc) 1)" "((fmap inc dec) 1)" "((comp inc dec) 1)" "((fmap inc dec) 1)" "(fmap inc dec)" "(fmap (fmap inc dec) 1)" "(fmap inc 1)" "(fmap (comp inc dec) 1)" "(fmap (fmap inc dec) 1)" "((fmap inc dec) 1)" "(isa? inc clojure.lang.Fn)" "(isa? (type inc) clojure.lang.Fn)" "(type inc)" "(ancestors inc)" "(parents inc)" "(ancestors (type inc))" "\\n(fmap inc dec)" ";; Switching to org.uncomplicate.redcat.core namespace" "\\n(fmap inc dec)" ";; Switching to org.uncomplicate.redcat.core namespace" "\\n(fmap inc dec)" "(doc comp)" ";; Switching to org.uncomplicate.redcat.core namespace" "1" "(doc comp)" "(source comp)" "(comp inc dec)" "((comp inc dec dec) 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "((comp inc dec dec) 1)" "(doc comp)" "(use 'clojure.repl)" "(doc comp)" "((comp inc dec dec) 1)" "((fmap inc dec dec) 1)" "((fmap inc dec) 1)" "(fmap inc dec)" "*ns*" "(fmap inc dec)" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap inc dec)" "((fmap inc dec) 1)" "((fmap inc dec) 1 2)" "((fmap inc\\n       ) 1 2)" "(fmap [(fmap inc dec)] [1])" "(fmap inc dec)" "(comp inc dec)" "(def a (comp inc dec))" "a" "(fmap inc dec)" "(a 1)" "(def b (fmap inc dec))" "(b 1)" "((fmap inc dec inc) 1)" "((fmap inc dec) 1)" "(b 1)" "(def c (fmap inc dec))" "(c 1)" "(b 1)" "((fmap inc dec dec) 1)" "(fmap inc dec inc)" "(def d (fmap inc dec inc))" "(d 1)" "((fmap inc dec) 1\\n                )" "((fmap inc dec dec) 1)" "((apply comp inc dec [dec]) 1)" "((fmap inc dec dec) 1)" "((fmap inc) 1)" "((fmap inc) dec)" "((fmap inc) [1])" "((fmap inc) dec)" "(p/fmap inc)" "((fmap inc) [1])" "((fmap inc dec) [1])" "(fmap inc dec)" "((fmap inc) [1])" "*ns*" ";; Switching to org.uncomplicate.redcat.core namespace" "((fmap inc) [1])" "((fmap inc dec) [1])" "((fmap inc dec) 1)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.uncomplicate.redcat.jvm)))" "*ns*" "((fmap inc dec) 1)" "(ancestors dec)" "(fmap inc [1])" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap inc [1])" "((fmap inc dec) 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "((fmap inc dec) 1)" "(fmap inc dec)" "((apply comp inc dec [dec]) 1)" "((comp inc dec dec) 1)" "(fmap inc dec)" "((fmap inc dec) 1)" "((fmap inc dec dec) 1)" "((fmap inc dec) 1)" "(((partial comp inc) dec) 1)" "(((partial (partial comp inc) dec) dec) 1)" "(time (count (fmap inc (fmap dec v))))" "(def v (vec (take 10000000 (iterate inc 0))))" "(source take)" "(use 'clojure.repl)" "doc" "(source take)" "(source vec)" "(time (count (fmap inc (fmap dec v))))" "(time (count (fmap inc dec) v))" "(time (count (fmap (fmap inc dec) v)))"]
eclipse.preferences.version=1
