cmdhistory=["(fmap inc [1 2 3])" "(time fmap inc (take 10000000 (iterate inc 0)))" "(time (fmap inc (take 10000000 (iterate inc 0))))" "*ns*" "(time (fmap inc (take 10000000 (iterate inc 0))))" "(time (fmap inc (take 1000000 (iterate inc 0))))" "\=> (time (last (fmap inc (take 1000000 (iterate inc 0)))))" "\\n(time (last (fmap inc (take 1000000 (iterate inc 0))\\n                     )))" "\\n(time (last (map inc (take 1000000 (iterate inc 0))\\n                     )))" "(doc defprotocol)" "(in-ns 'cats.protocols)\\n(extend-protocol Functor\\n  nil\\n    nil\\n  clojure.lang.ISeq\\n    (fmap [v g] (into (empty v) (map g v))))\\n(in-ns 'cats.core)" "(fmap nil nil)" "(fmap inc nil)" "(seq? nil)" "(sequable? nil)" "(sequential? nil)" "(isa? nil clojure.lang.ISeq)" "(fmap inc nil)" "(seq 1)" "(p/<*> [inc] \\n       [1 2])" "(pure [] 1\\n      )" "(p/pure [] 1\\n      )" "(p/pure (seq []) 1\\n      )" "(p/pure (seq [1]) 1\\n      )" "(p/<*> [inc] 1\\n      )" "(isa? clojure.lang.PersistentVector clojure.lang.ISeq)" "(isa? clojure.lang.PersistentVector clojure.lang.IPersistentVector\\n      )" "(parents clojure.lang.PersistentVector)" "(doc parents)" "(doc-search parents)" "(search-doc parents)" "(ancestors clojure.lang.PersistentVector)" "(doc clojure.lang.Seqable)" "(p/pure [] 1\\n      )" "(fmap inc nil)" "(p/<*> [inc] 1\\n      )" "(fmap inc [1 2])" "(p/<*> [inc] 1\\n      )" "(doc extend-protocol)" "(p/<*> [inc] 1\\n      )" "(pure nil  1)" "(pure [nil]  1)" "(p/pure [nil]  1)" "(p/pure nil  1)" "\:*" "(p/pure nil  1)" "(p/pure [nil]  1)" "(p/<*> [inc] 1\\n      )" "(doc zipmap)" "(doc for)" "(p/<*> [inc dec] \\n       1\\n      )" "(p/<*> [inc dec] \\n       [1 100]\\n       \\n      )" "Monad" "*ns*" "cats.protocol/Monad" ";; Switching to cats.protocols namespace" "*ns*" "Monad" "(wrap [] 1)" "(wrap (Identity.) 1)" "(wrap (Identity. 1) 1)" "(type Identity)" "Identity" "(bind (wrap (Identity. 1) 1) inc)" "(bind (wrap (Identity. 1) 1) \#(Identity. (inc %)))" "(bind \\n  (Identity. 1) \#(Identity. (inc %)))" "(doc deftype)" "(isa? Monad nil)" "(isa? nil Monad )" "(wrap nil 1)" "(or nil 1)" "(Just 1)" "(Just.\\n  1)" "(Identity. 1)" "(bind (Just. 1) \#(Just. (inc %)))" "(.v (Just 5))" "(.v (Just. 5))" "(bind (Just. 1) \#(Just. (inc %)))" "(.v (bind (Just. 1) \#(Just. (inc %))))" "(.v (bind nil \#(Just. (inc %))))" "(doc defprotocol)" "(defprotocol P)" "(defprotocol P [])" "(defprotocol P ())" "(defprotocol P '())" "(.v (Just. 3))" "(.v (bind (Just. 3)))" "(def m-inc (fn [a] (Just. (inc a))))" "(.v (bind (Just. 3) m-inc))" "(.v (bind (Maybe. 3) m-inc))" "(defprotocol P '())" "MaybeM" ";; Switching to cats.protocols namespace" "(def m-inc (fn [a] (Just. (inc a))))" ";; Switching to cats.protocols namespace" "(def m-inc (fn [a] (Just. (inc a))))" "(.v (bind (Just. 3) m-inc))" "(.v (bind nil m-inc))" "(def m-inc (fn [a] (Just. (inc a))))" "(.v (bind nil m-inc))" "(bind nil m-inc)" "(.v (bind (Identity. 2) m-inc))" "(bind (Identity. 2) m-inc)" "(deftype MonadImpl [m-type]\\n  (wrap [v] (m-wrap m-type v))\\n  (bind [mv g] \\"aa\\"))" "(defprotocol Monad\\n  \\"TODO documentation\\"\\n  (wrap [_ v])\\n  (bind [mv g])\\n  (>> [ma mb])\\n  ;m >> n \= m >>\= \\\\_ -> n\\n  (fail [^String s]))" "(deftype MonadImpl [m-type]\\n  (wrap [v] (m-wrap m-type v))\\n  (bind [mv g] \\"aa\\"))" "(defprotocol Monad\\n  \\"TODO documentation\\"\\n  (wrap [v])\\n  (bind [mv g])\\n  (>> [ma mb])\\n  ;m >> n \= m >>\= \\\\_ -> n\\n  (fail [^String s]))" "(deftype MonadImpl [m-type]\\n  (wrap [v] (m-wrap m-type v))\\n  (bind [mv g] \\"aa\\"))" "(deftype MonadImpl [m-type]\\n  (wrap [v] (m-wrap m-type v)\\n  (bind [mv g] \\"aa\\"))" "(deftype MonadImpl [m-type]\\n  (wrap [v] (m-wrap m-type v)\\n  (bind [mv g] \\"aa\\")))" "(defprotocol Monad\\n  \\"TODO documentation\\"\\n  (wrap [v])\\n  (bind [mv g])\\n  (>> [ma mb])\\n  ;m >> n \= m >>\= \\\\_ -> n\\n  (fail [^String s]))" "(deftype MonadImpl [m-type]\\n  (wrap [v] (m-wrap m-type v)\\n  (bind [mv g] \\"aa\\")))" "(defprotocol Monad\\n  \\"TODO documentation\\"\\n  (wrap [v])\\n  (bind [mv g])\\n  (>> [ma mb])\\n  ;m >> n \= m >>\= \\\\_ -> n\\n  (fail [^String s]))" "(defprotocol MonadInstance\\n  (m-wrap [v]))" "(deftype MonadImpl [m-instance]\\n  (wrap [v] (m-wrap m-instance v)\\n  (bind [mv g] \\"aa\\")))" "(deftype MonadImpl [m-instance]\\n  (wrap [v] (m-wrap m-instance v))\\n  (bind [mv g] \\"aa\\"))" "(defprotocol MonadInstance\\n  (m-wrap [v]))" "(deftype MonadImpl [m-instance]\\n  Monad\\n  (wrap [v] (m-wrap m-instance v))\\n  (bind [mv g] \\"aa\\"))" "(defprotocol MonadInstance\\n  (m-wrap [_ v]))" "(deftype MonadImpl [m-instance]\\n  Monad\\n  (wrap [v] (m-wrap m-instance v))\\n  (bind [mv g] \\"aa\\"))" "(defprotocol Monad\\n  \\"TODO documentation\\"\\n  (wrap [_ v])\\n  (bind [mv g])\\n  (>> [ma mb])\\n  ;m >> n \= m >>\= \\\\_ -> n\\n  (fail [^String s]))" "(extend-protocol Monad \\n  nil\\n    (wrap [_ _] nil)\\n    (bind [_ _] nil))" "(deftype Identity [v]\\n  Monad\\n    (wrap [_ v] (Identity. v))\\n    (bind [mv g] (g (.v mv))))" "(deftype Maybe [v]\\n  Monad\\n    (wrap [_ v] (Maybe. v))\\n    (bind [jv g] (if jv (g (.v jv)) nil)))" ";; Switching to cats.protocols namespace" "(.v (bind (wrap [] 1) m-inc)" "(defn m-inc [v] [inc v])" "(.v (bind (wrap [] 1) m-inc))" "(bind (wrap [] 1) m-inc)" "(defn m-inc [v] [(inc v)])" "(bind (wrap [] 1) m-inc)" "(doc mapcat)" "(bind [1 2 34 ] m-inc)" "(mapcat inc [1 2 3])" "(map m-inc [1 2 3])" "(doc definterface)" "(doc gen-interface)" "Monad" "(doc swap\!)" "m-inc" ";; Switching to cats.core namespace" ";; Switching to cats.protocols namespace" "(deref [f])" "(doc concat)" "(concat [[1] [2]])" "(doc concat)" "(concat [1] [2] [3])" "(apply concat [[1] [2] [3]])" "(lift inc [1])" ";; Switching to cats.core namespace" "(lift inc [1])" ";; Switching to cats.core namespace" "(lift inc [1])" "(fmap inc [1])" "(vec 1)" "(vector 1)" "(seq 1)" "(sequence 1)" "(extend-type nil)" "(deref nil)" "(doc replicate)" "(doc repeat)" "((partial repeat 3) 1)" ";; Switching to cats.core namespace" "(defn fmap [f c]\\n  (p/fmap c f))" "(defn pure p/wrap)" "(replicate 3 [1 2])" "(doc reverse)" "(doc replicate)" ";; Switching to cats.core namespace" "(doc id)" "(doc concat)" ";; Switching to cats.protocols namespace" "(id [1 2 3])" "(<> [1 2] [3 4])" "(doc *)" "(doc plus)" "(plus [1] [2])" "(doc sum)" "(fold [1 2 3])" "(fmap + [1 2 3])" "(fold [1 2 3])" "(fold [[1] [2] [3]])" "(type 1)" "(fold plus v)" "(fold plus [[2][3]])" "(foldmap [2 3] vector)" "(fmap [1 2] vector)" "(fmap [1 2] list)" "(foldmap [2 3] list)" ";; Switching to org.uncomplicate.redcat.protocols namespace" "(fmap inc [1 2])" "(use 'org.uncomplicate.redcat.jvm)" "(fmap inc [1 2])" ";; Switching to org.uncomplicate.redcat namespace" "(use 'org.uncomplicate.redcat.jvm)" "(fmap inc [1 2])" "(doc conj)" "(fmap inc [1 2])" "(def t (vec (iterate inc 1)))" "(last t)" "(first t)" "(vec '(1))" "(\\n  doc vector)" "(def t (vec (take 1000000 (iterate inc 1))))" "(last t)" "(time (last (fmap inc t)))" "(time (last (map inc t)))" "(def t1 (seq t))" "(time (last (map inc t1)))" "(time (last (fmap inc t1)))" "(def t1 (iterate inc 1))" "(time (last (fmap inc t1)))" "(def t1 (take 1000000 (iterate inc 1)))" "(time (last (fmap inc t1)))" "(time (last (map inc t1)))" "(time (last (fmap inc t1)))" "(doc lazy-seq)" "(time (last (fmap inc t)))" "p" "(time (last (fmap inc t)))" "(take 10 t)" "(time (last (fmap inc t)))" "(time (last t))" "(time (first t))" "([1 2] 1)" "(time (t 1))" "(time (t 1000000))" "(time (t 100000))" "(time (t 9999999))" "(time (t 999999))" "(time (t 1))" "(time (fmap inc t))" "(time (type (fmap inc t)))" "(time (type (fmap identity t)))" "(time (type (\\n              map identity t)))" "(time (type (into [] (map identity t))))" "(doc coll-reduce)" "(coll-reduce + [1 2])" ";; Switching to org.uncomplicate.redcat.protocols namespace" ";; Switching to org.uncomplicate.redcat namespace" "(doc coll-reduce)" "(coll-reduce + [1 2])" "(use [clojure.core.protocols \:as pro])" "(use '[clojure.core.protocols \:as pro])" "(doc coll-reduce)" "(coll-reduce + [1 2])" "(coll-reduce [1 2] +)" "(require '[clojure.core.reducers \:as r])" "(time (type (into [] (r/map identity t))))" "(def t (vec (take 1000000 (iterate inc 1))))" "(time (type (into [] (r/map identity t))))" "(time (type (into [] (fmap identity t))))" "p" "(r/map identity t)" "((r/map identity t))" "(first (r/map identity t))" "(r/reduce + [1 2])" "(time (r/reduce + t))" "(time (reduce + t))" "(time (p/reduce + t))" "(time (r/reduce + t))" "(time (reduce + t))" "(time (type (fmap identity t)))" "(time (type (map identity t)))" "(time (size (map identity t)))" "(time (count (map identity t)))" "(time (count (fmap identity t)))" "(time (count (r/map identity t)))" "(time (count (seq (r/map identity t))))" "(time (count (into []\\n                   (r/map identity t))))" "(time (count (fmap identity t)))" "p" "(time (count (fmap identity t)))" "p" "^map" "(meta map)" "(doc source)" "(source map)" "(source reduce)" "(source r/reduce)" "(source coll-reduce)" "(doc conj\!)" "(source conj\!)" "CollReduce" "(time (count (fmap identity t)))" "p" "(take 10 (fmap identity (iterate inc 0)))" "(doc clojure.lang.IEditableCollection)" "(doc transient)" "(transient (seq [1]))" "(transient [5])" "(transient '(5))" "(take 10 (fmap identity (iterate inc 0)))" "*ns*" "(doc fmap)" "(take 10 (fmap identity (iterate inc 0)))" "(take 10 (fmap identity (vec (iterate inc 0))))" "(take 10 (fmap identity (iterate inc 0)))" "(take 10 (fmap (iterate inc 0) identity))" "(take 10 (r/map identity (iterate inc 0)))" "(take 10 (seq (fmap (iterate inc 0) identity)))" "(take 10 (seq (r/map identity (iterate inc 0))))" "(take 10 (into [] (r/map identity (iterate inc 0))))" "(take 10 (fmap identity (iterate inc 0)))" "(count (fmap identity (iterate inc 0)))" "(take 10 (fmap identity t))" "(take 10 (iterate inc 0))" "(lazy-seq [1 2])" "(fmap identity (lazy-seq [1 2]))" "(type (lazy-seq [1 2]))" "(isa? (lazy-seq [1 2]) clojure.lang.IPersistentCollection)" "(empty (lazy-seq [1 2]))" "(into (empty []) (map inc  (lazy-seq [1 2])))" "(fmap identity (lazy-seq [1 2]))" "(fmap identity [1 2])" "(fmap identity '(1 2))" "(fmap identity \#(1 2))" "(fmap identity \#{1 2})" "(r/map identity \#{1 2})" "(r/map identity [1 2])" "(doc r/fold)" "(fold conj (r/map inc [1 2]))" "(r/fold conj (r/map inc [1 2]))" "(r/fold conj [] (r/map inc [1 2]))" "(r/fold + (r/map inc [1 2]))" "(source r/fold)" "(r/fold conj [] (r/map inc [1 2]))" "(r/fold [] conj (r/map inc [1 2]))" "(r/fold conj conj (r/map inc [1 2]))" "(doc r/monoid)" "(source r/monoid)" "(empty (lazy-seq [1 2]))" "(fmap inc [1 2])" "(fmap inc (seq [1 2]))" "(fmap inc (seq '(1 2)))" "(map inc (seq '(1 2)))" "(fmap inc (lazy-seq '(1 2)))" "(fmap inc (lazy-seq [1 2]))" "(fmap inc \#{1 2})" "(fmap inc (lazy-seq \#{1 2}))" "(r/map inc \#{1 2})" "(conj \#{} (first (r/map inc \#{1 2})))" "((first (r/map inc \#{1 2}))" "(first (r/map inc \#{1 2})" "(first (r/map inc \#{1 2}))" "(into \#{} (r/map inc \#{1 2}))" "(source into)" "(reduce conj \#{} (r/map inc \#{1 2}))" "(r/reduce conj \#{} (r/map inc \#{1 2}))" "(r/reduce conj (empty \#{}) (r/map inc \#{1 2}))" "(fmap inc \#{1 2})" "(p/fmap inc \#{1 2})" "(p/fmap \#{1 2} inc)" "(p/fmap inc \#{1 2})" "(fmap inc \#{1 2})" "(doc r/map)" "(fmap inc \#{1 2})" "(fmap inc {1 2})" "(fmap identity {1 2})" "(fmap identity (lazy-seq [1 2]))" ";; Switching to org.uncomplicate.redcat namespace" "(fmap identity (lazy-seq [1 2]))" "(doc for)" "(source for)" "(doc mapcat)" "(doc conj)" "(time (count (map \#(conj (empty []) %) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(vec %) (take 1000000 (iterate inc 0))\\n                  )))" "(vec 1)" "(vetor 1)" "(time (count (map \#([%]) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(vec %) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(vec [%]) (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map vec (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map list (take 1000000 (iterate inc 0))\\n                  )))" "(time (count (map \#(conj (empty (list)) %) (take 1000000 (iterate inc 0))\\n                  )))" "(time [])" "(time (empty []))" "(source mapcat)" "(doc r/map)" "r/map" "(defn incm [x] [(inc x)])" "(incm 1)" "(mapcat incm [1])" "(mapcat incm [1 2 3])" "(map incm [1 2 3])" "  (require '[clojure.core.reducers \:as r])" "(into [] (r/map incm [1 2 3]))" "(source concat)" "(find-doc conj)" "(find-doc \\"conj\\")" "(find-var \\"conj\\")" "(find-var \\n  conj)" "(find-var 'conj)" "(doc find-var)" "(into [1 2] [3 4])" "(concat [1 2] [3 4])" "(reduce into (r/map incm [1 2 3]))" "(reduce into [] (r/map incm [1 2 3]))" "(bind [1 2 3] incm)" "bind" ">>\=" "(p/bind [1 2 3] incm)" "(r/reduce into (r/map incm [1 2 3]))" "(p/bind [1 2 3] incm)" "(r/reduce into [] (r/map incm [1 2 3]))" "(apply concat [[1] [2] [3]])" "(source concat)" "(join [(list 1 2) (list 3 4)])" "(r/join [(list 1 2) (list 3 4)])" "(p/join [(list 1 2) (list 3 4)])" "(p/join [[1 2] [3 4]])" "(p/bind sum [[1 2] [3 4]])" "(p/bind incm [[1 2] [3 4]])" "(p/bind [[1 2] [3 4]] incm)" "(p/bind [1 2 3 4] incm)" "(p/join [[1 2] [3 4]])" "(p/reduce into [[1 2] [3 4]])" "(reduce into [[1 2] [3 4]])" "(r/reduce into [[1 2] [3 4]])" "(r/reduce into []\\n          [[1 2] [3 4]])" "(p/join [[1 2] [3 4]])" "(reduce into [[1 2] [3 4]])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "join" "(join [[1 2] [3 4]])" "(defn incm [x] [(inc x)])" "(bind [[1 2] [3 4]] incm)" "(join [[1 2] [3 4]])" "(bind [[1 2] [3 4]] incm)" "(bind [[2] [4]] incm)" "r" "r/cat" "(r/map [[2] [4]] incm)" "(first \\n  (r/map [[2] [4]] incm))" "(bind [2 4] incm)" "(r/map incm [2 4])" "(first (r/map incm [2 4]))" "(count (r/map incm [2 4]))" "(reduce into (r/map incm [2 4]))" "(reduce into [] (r/map incm [2 4]))" "(r/reduce into [] (r/map incm [2 4]))" "(reduce into [[2] [4]])" "(join '([1 2] [3 4]))" "(join '([1 2] (3 4)))" "(join '([1 2] {3 4}))" "(first (r/map inc [1 2]))" "(bind [2 4] incm)" "(r/reduce into [[1 2] [3]])" "(doc r/reduce)" "(into)" "(fmap [2 4] incm)" "(bind [2 4] incm)" "(bind \#{2 4} incm)" "(fmap \#{2 4} inc)" "(bind \#{2 4} incm)" "(join '([1 2] {3 4}))" "(fmap \#{2 4} inc)" "(fmap \#(fmap \#{2 16} %) [inc exp])" "(fmap \#(fmap \#{2 16} %) [inc (partial * 100)\\n                         ])" "(fmap [inc (partial * 100)] \#(fmap \#{2 16} %))" "(<*> [inc (partial * 100)] [1 2])" "(doc for)" "(r/map [inc (partial * 100)] \#(r/map \#{2 16} %))" "(join (r/map [inc (partial * 100)] \#(r/map \#{2 16} %)))" "(r/reduce into [] (r/map [inc (partial * 100)] \#(r/map \#{2 16} %)))" "(into [] (r/map [inc (partial * 100)] \#(r/map \#{2 16} %)))" "(fmap [inc (partial * 100)] \#(fmap \#{2 16} %))" "(join (fmap [inc (partial * 100)] \#(fmap \#{2 16} %)))" "(<*> [inc (partial * 100)] [1 2])" "(bind [1 2] [inc (partial * 100)])" "(bind [inc (partial * 100)] \#(fmap [1 2] %))" "(source apply)" "(<*> [inc (partial * 100)] [1 2])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(<*> [inc (partial * 100)] [1 2])" "(doc lazy-seq)" "(doc ralized?)" "(fmap (lazy-seq [1 2] inc))" "(fmap (lazy-seq [1 2]) inc))" "(r/map (lazy-seq [1 2]) inc)" "(lazy-seq (r/map (lazy-seq [1 2]) inc))" "(empty (lazy-seq [1 2]))" "(doc lazy-seq)" "(isa? (seq [1]) clojure.lang.LazySeq)" "(isa? (map identity (seq [1])) clojure.lang.LazySeq)" "(doc map)" "(instance? (map identity (seq [1])) clojure.lang.LazySeq)" "(instance? (map identity (seq [1])) clojure.lang.LazySeq.class)" "(type (map identity (seq [1])))" "(isa? clojure.lang.LazySeq clojure.lang.LazySeq)" "(isa? (type (map identity (seq [1]))) clojure.lang.LazySeq)" "(isa? (seq [1])) clojure.lang.LazySeq)" "(isa? (type (seq [1])) clojure.lang.LazySeq)" "(doc seq)" "(doc lazy-seq)" "(lazy-seq [1])" "(bind (lazy-seq [inc (partial * 100)]) \#(fmap [1 2] %))" "(wrap (lazy-seq []) 1)" "(type (wrap (lazy-seq []) 1))" "(source concat)" "(\= [1 2] [2 1])" "(id [ 1 2])" "id" "(id [ 1 2])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(id [ 1 2])" "(concat nil [1])" "(next [])" "(concat (seq [1]) nil)" "(into [1] nil)" "(into nil [1])" "(+ 1 nil)" "(doc r/fold)" "(fold + [1 2])" "(r/fold + [1 2])" "(r/fold plus [[1] [2]])" "(r/fold (monoid plus) [[1] [2]])" "(r/fold (r/monoid plus) [[1] [2]])" "(doc r/monoid)" "(r/fold (r/monoid plus []) [[1] [2]])" "(r/fold (r/monoid plus list) [[1] [2]])" "(r/fold (r/monoid plus vec) [[1] [2]])" "(doc [])" "(r/fold (r/monoid plus vector) [[1] [2]])" "(r/fold (r/monoid plus id) [[1] [2]])" "(r/fold (r/monoid + 0) [[1] [2]])" "(r/fold (r/monoid + 0) [1 2])" "(doc r/monoid)" "(vector)" "(r/fold (r/monoid plus (partial id [])) [[1] [2]])" "(first [])" "([] 0)" "(fold [[1] [2]])" "(doc op)" "(const 1)" "((constantly 1) 9)" "(opf [])" "(fold (opf []) [[1 2] [3 4]])" "(r/fold (opf []) [[1 2] [3 4]])" "(fold [[1 2] [3 4]])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(fold [[1 2] [3 4]])" "(doc +)" "(+ 1/2 1/3)" "(fold [1 2 3])" "(fold [1 2 3/3])" "(fold [1 2 2/3])" "(foldmap [1 2 2/3] (op-fun 1 *))" "(fold [1 2 2/3])" "(fold [1 2 2/3 9.99])" "(fold [1.0000000000000000000000000000000000001 2 2/3 9.99])" "(doc r/monoid)" "(fmap (atom 1) inc)" "(def a (atom 1))" "(fmap a inc)" "a" "(def r (ref 1))" "(fmap r inc)" "(do-sync (fmap r inc))" "(dosync (fmap r inc))" "r" "(atom)" "(atom nil)" "(<*> (atom inc) (atom 1))" "(join [[1 2] [3 4]])" "(join (atom (atom 1)))" "(atom (atom 1))" "(join (atom (atom 1)))" "a" "(def ma (atom a))" "ma" "(join ma)" "ma" "(bind (atom 1) \#(atom (inc %)))" "(fmap (atom 1) \#(atom (inc %)))" "(join [1 2])" "(bind [1 2] \#(vector (inc %)))" "(fmap [1 2] \#(vector (inc %)))" "(fmap (atom 1) \#(atom (inc %)))" "(swap\! (atom 1) \#(atom (inc %)))" "(swap\! (atom 1) inc)" "(set\! (atom 1) 2)" "(doc set\!)" "(fmap (atom 1) \#(atom (inc %)))" "(<*> (atom inc) (atom 1))" "(join (atom (atom 1)))" "(bind (atom 1) \#(atom (inc %)))" "(bind (ref 1) \#(atom (inc %)))" "(dosync (bind (ref 1) \#(atom (inc %))))" ";; Switching to org.uncomplicate.redcat namespace" "(fmap [1 2 3] inc)" "(fmap inc [1 2 3])" "((fmap inc) [1 2 3])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(doc r/map)" "(source r/map)" "(source map)" "((fmap inc) [1 2 3])" ";; Switching to org.uncomplicate.redcat.core namespace" "((fmap inc) [1 2 3])" "(doc reverse)" "(reverse \\"abc\\")" "(doc str)" "(doc l (iterate inc 1000000))" "(def l (iterate inc 1000000))" "(str [1 2 3])" "(apply str [1 2 3])" "(def s (apply str l))" "1" "(empty \\"a\\")" "(into (empty \\"a\\") \\"abc\\")" "(fmap reverse \\"abc\\")" "(fmap reverse (seq \\"abc\\"))" "(fmap reverse \\"abc\\")" "(reverse \\"abc\\")" "(time (reverse \\"abc\\"))" "(time (fmap reverse \\"abc\\"))" "(time (reverse \\"abc\\"))" "(time (fmap reverse \\"abc\\"))" "(time (fmap (comp reverse reverse) \\"abc\\"))" "(fmap inc dec)" "((fmap inc dec) 1)" "(source map)" "(doc map)" "(doc str)" "(doc ->)" "(doc protocol)" "(doc defprotocol)" "(fmap inc 1 2 3)" "(fmap inc [1 2 3])" "(str 1)" "(fmap str [1 2 3])" "(doc fmap)" "((fmap str inc) 1)" "((fmap str dec) 1)" "((fmap dec str) 1)" "((comp dec str) 1)" "((comp str dec) 1)" "((fmap str inc) 1)" "((fmap (partial * 3) (partial + 100) 1)" "((fmap (partial * 3) (partial + 100)) 1)" "((fmap str) 1)" "((fmap str) [1])" "((fmap str) [1 2 3])" "(doc fold)" "(doc fmap)" "(fmap identity [1 2 3])" "(\= identity (fmap identity))" "(\= identity identity)" "(fmap inc 1)" "(and (function? inc) inc)" "(and (fn? inc) inc)" "(\= (and (fn? inc) inc) inc)" "(or 1 2)" "(fmap identity [1 2 3])" "(fmap identity nil)" "(\= (atom 1) (atom 1))" "(def a (atom 1))" "(seq [2 3 4])" "(\= [1] (seq [1]))" "(\=\= [1] (seq [1]))" "(seq? [1])" "(for [a [1 2 3]] (inc a))" "(doc for)" "1" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(gen/long)" "gen" ";; Switching to org.uncomplicate.redcat.core-test namespace" "gen" "(gen/long)" "(defspec [^int seed ^{\:tag (uniform 1 100)} iters])" "(gen/defspec [^int seed ^{\:tag (uniform 1 100)} iters])" "(gen/defspec ^int seed ^{\:tag (uniform 1 100)} iters)" "(defspec longs-are-closed-under-increment\\n  inc ;; function under test\\n  [^long l]  ;; indicates generation via gen/long\\n  (assert (instance? Long %)))" "(gen/defspec longs-are-closed-under-increment\\n  inc ;; function under test\\n  [^long l]  ;; indicates generation via gen/long\\n  (assert (instance? Long %)))" "(longs-are-closed-under-increment 4)" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(gen/)" "(gen/vec gen/anything)" "(gen/vec gen/boolean)" "(gen/vec gen/int)" "(gen/one-of inc dec)" "(gen/one-of [inc dec])" "((gen/one-of [inc dec]))" "(gen/oneof 1 2)" "(gen/one-of 1 2)" "p" "(gen/oneof 1 2)" "(gen/one-of 1 2)" "*num-trials*" "(require '[midje.ideas.formulas \:as ideas])" "ideas/*num-trials*" "(gen/one-of inc dec)" "(gen/one-of 1 2)" "(gen/one-of 1 2 3)" "(gen/one-of 1 2 \:d)" "(gen/one-of 1 2 inc)" "inc" "(gen/one-of 1 2 [\\n                 inc])" "(gen/one-of 1 2 inc)" "((gen/one-of dec inc) 1)" "((gen/one-of 'dec 'inc) 1)" "(doc gen/one-of)" "(source gen/one-oof)" "(source gen/one-o\\n        f)" "(source gen/one-of)" "[inc dec]" "(gen/one-of inc)" "(doc formula)" "(source formula)" "(macroexpand (functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(macroexpand '(functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(formula [f1 (first (gen/one-of [inc] [dec] [(partial * 100)]))\\n          f2  (first (gen/one-of [inc] [dec] [(partial * 100)]))\\n          x (gen/int)]\\n              (fmap (comp f1 f2) x) \=> (fmap f1 (fmap f2 x)))" "(macroexpand '(functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(doc gen/int)" "(def args [inc (partial * 100)])" "(gen/one-of args)" "(apply gen/one-of args)" "((apply gen/one-of args) 1)" "((apply gen/one-of inc dec) 1)" "((gen/one-of inc dec) 1)" "((gen/one-of [inc] [dec]) 1)" "(gen/one-of [inc] [dec])" "args" "(apply gen/one-of args)" "(apply gen/one-of '([inc] [dec]))" "args" "(def args '(inc dec))" "(apply gen/one-of args)" "args" "(gen/one-of inc dec)" "(apply gen/one-of '(inc dec))" "(defn gen-fn [&fs]\\n  (first (apply gen/one-of (map vector fs))))" "(defn gen-fn [fs]\\n  (first (apply gen/one-of (map vector fs))))" "(defn gen-fn [&fs]\\n  (first (apply gen/one-of (map vector ~fs))))" "(doc gen/vec)" "(doc isa?)" "(doc formula)" "((comp inc val) (first {\:a 1}))" "(fmap (comp inc val) {\:a 1})" "(type (first {\:a 1}))" "(into {} (type (first {\:a 1})))" "(into {} (first {\:a 1}))" "\\n(first {\:a 1}))" "(into {} [\:a \:b])" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(fmap inc \#(clojure.lang.MapEntry (gen/keyword) (gen/int))" "(fmap inc \#(clojure.lang.MapEntry (gen/keyword) (gen/int)))" "(type (fmap inc (clojure.lang.MapEntry (gen/keyword) (gen/int))))" "(type (fmap inc (clojure.lang.MapEntry. (gen/keyword) (gen/int))))" "10000000000000000000000000000000000000000" "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000*100" "(* 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 100000)" "(+ 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(unsigned-+ 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(unchecked-add 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(doc unchecked-add)" "(find \\"lazy\\")" "(doc find)" "(doc-find \\"lazy)" "(doc-find \\"lazy\\")" "(find-doc \\"lazy\\")" "(fmap inc (seq [1]))" "(type (fmap inc (seq [1])))" "(type (seq [1]))" "(sourc seq)" "(source seq)" "(reverse \\"aaaabbb\\")" "(map reverse str)" "(map reverse \\"ab\\")" "(map char? \\"aa\\")" "(fmap char? \\"aa\\")" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(fmap inc {\:a 1})" "(fmap (fmap inc) {\:a 1})" "(fmap (fmap inc) {2 1})" "(fmap key {1 2})" "(fmap key {\:a \:b})" "(key (first {\:a \:b}))" "(fmap key (first {\:a \:b}))" "\\n*ns*" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap key (first {\:a \:b}))" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap key (first {\:a \:b}))" "(fmap type (first {\:a \:b}))" "(fmap type {\:a \:b})" "(map type {\:a \:b})" "(map type {\:a \:b \:c \:d})" "(fmap type {\:a \:b \:c \:d})" "(r/map type {\:a \:b \:c \:d})" "(require '[clojure.core.reducers \:as r])" "(r/map type {\:a \:b \:c \:d})" "(into {} (r/map type {\:a \:b \:c \:d}))" "(into {} (r/map (fmap type) {\:a \:b \:c \:d}))" "(fmap type (first {\:a \:b}))" "(fmap (fmap type) {\:a \:b})" "(fmap + [1 2 3])" "(pure [] +)" "(fmap inc [1 2 3])" "(fmap and)" "(&& true false)" "(\= false true)" "(\= false)" "(fmap \= [false true])"]
eclipse.preferences.version=1
