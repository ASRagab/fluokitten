cmdhistory=["(gen/one-of 1 2 3)" "(gen/one-of 1 2 \:d)" "(gen/one-of 1 2 inc)" "inc" "(gen/one-of 1 2 [\\n                 inc])" "(gen/one-of 1 2 inc)" "((gen/one-of dec inc) 1)" "((gen/one-of 'dec 'inc) 1)" "(doc gen/one-of)" "(source gen/one-oof)" "(source gen/one-o\\n        f)" "(source gen/one-of)" "[inc dec]" "(gen/one-of inc)" "(doc formula)" "(source formula)" "(macroexpand (functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(macroexpand '(functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(formula [f1 (first (gen/one-of [inc] [dec] [(partial * 100)]))\\n          f2  (first (gen/one-of [inc] [dec] [(partial * 100)]))\\n          x (gen/int)]\\n              (fmap (comp f1 f2) x) \=> (fmap f1 (fmap f2 x)))" "(macroexpand '(functor-law2 (first (gen/one-of [inc] [(partial * 10)])) (gen/int)))" "(doc gen/int)" "(def args [inc (partial * 100)])" "(gen/one-of args)" "(apply gen/one-of args)" "((apply gen/one-of args) 1)" "((apply gen/one-of inc dec) 1)" "((gen/one-of inc dec) 1)" "((gen/one-of [inc] [dec]) 1)" "(gen/one-of [inc] [dec])" "args" "(apply gen/one-of args)" "(apply gen/one-of '([inc] [dec]))" "args" "(def args '(inc dec))" "(apply gen/one-of args)" "args" "(gen/one-of inc dec)" "(apply gen/one-of '(inc dec))" "(defn gen-fn [&fs]\\n  (first (apply gen/one-of (map vector fs))))" "(defn gen-fn [fs]\\n  (first (apply gen/one-of (map vector fs))))" "(defn gen-fn [&fs]\\n  (first (apply gen/one-of (map vector ~fs))))" "(doc gen/vec)" "(doc isa?)" "(doc formula)" "((comp inc val) (first {\:a 1}))" "(fmap (comp inc val) {\:a 1})" "(type (first {\:a 1}))" "(into {} (type (first {\:a 1})))" "(into {} (first {\:a 1}))" "\\n(first {\:a 1}))" "(into {} [\:a \:b])" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(fmap inc \#(clojure.lang.MapEntry (gen/keyword) (gen/int))" "(fmap inc \#(clojure.lang.MapEntry (gen/keyword) (gen/int)))" "(type (fmap inc (clojure.lang.MapEntry (gen/keyword) (gen/int))))" "(type (fmap inc (clojure.lang.MapEntry. (gen/keyword) (gen/int))))" "10000000000000000000000000000000000000000" "10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" "1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000*100" "(* 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 100000)" "(+ 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(unsigned-+ 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(unchecked-add 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 1)" "(doc unchecked-add)" "(find \\"lazy\\")" "(doc find)" "(doc-find \\"lazy)" "(doc-find \\"lazy\\")" "(find-doc \\"lazy\\")" "(fmap inc (seq [1]))" "(type (fmap inc (seq [1])))" "(type (seq [1]))" "(sourc seq)" "(source seq)" "(reverse \\"aaaabbb\\")" "(map reverse str)" "(map reverse \\"ab\\")" "(map char? \\"aa\\")" "(fmap char? \\"aa\\")" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(fmap inc {\:a 1})" "(fmap (fmap inc) {\:a 1})" "(fmap (fmap inc) {2 1})" "(fmap key {1 2})" "(fmap key {\:a \:b})" "(key (first {\:a \:b}))" "(fmap key (first {\:a \:b}))" "\\n*ns*" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap key (first {\:a \:b}))" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap key (first {\:a \:b}))" "(fmap type (first {\:a \:b}))" "(fmap type {\:a \:b})" "(map type {\:a \:b})" "(map type {\:a \:b \:c \:d})" "(fmap type {\:a \:b \:c \:d})" "(r/map type {\:a \:b \:c \:d})" "(require '[clojure.core.reducers \:as r])" "(r/map type {\:a \:b \:c \:d})" "(into {} (r/map type {\:a \:b \:c \:d}))" "(into {} (r/map (fmap type) {\:a \:b \:c \:d}))" "(fmap type (first {\:a \:b}))" "(fmap (fmap type) {\:a \:b})" "(fmap + [1 2 3])" "(pure [] +)" "(fmap inc [1 2 3])" "(fmap and)" "(&& true false)" "(\= false true)" "(\= false)" "(fmap \= [false true])" "(<*> [inc] [1 2 3])" "(ap [inc] [1 2 3])" "(doc r/map)" "(source map)" "(r/map + [1 2 3])" "(into [] (r/map + [1 2 3]))" "(into [] (r/map + [1 2 3] [4 5 6]))" "(time (count (take 1000000 (map inc (iterate inc 0)))))" "(time (count (take 1000000 (fmap inc (iterate inc 0)))))" "(def v (vec (take 1000000 (iterate inc 1000000))))" "(def s (seq (take 1000000 (iterate inc 1000000))))" "(count s)" "(time (count (take 1000000 s)))" "(time (count (take 1000000 v)))" "(time (count v))" "(time (count s))" "(time (last s))" "(time (last v))" "p" "(time (last v))" "(time (first v))" "(type v)" "(time (count (fmap inc v)))" "(time (count (fmap inc s)))" "(time (count (map inc s)))" "(time (count (fmap inc s)))" "(time (count (take 100000000 v)))" "(def v (vec (take 1000000 (iterate inc 100000000))))" "(def v (vec (take 100000000 (iterate inc 1))))" "(def v (vec (take 10000000 (iterate inc 1))))" "(def s (seq (take 10000000 (iterate inc 1))))" "(count s)" ";; Switching to org.uncomplicate.redcat.core namespace" "(ap [inc (partial * 100)] [1 10 50])" "(use 'org.uncomplicate.redcat.jvm)" "(ap [inc (partial * 100)] [1 10 50])" "(<*> [inc (partial * 100)] [1 10 50])" "(fmap inc [1 10 50])" "(fmap [inc] [1 10 50])" "(ap [inc] [1 10 50])" "(join [[1] [2]])" "(p/join [[1] [2]])" "(p/<*> [inc] [1 10 50])" "(ap [inc] [1 10 50])" "(p/<*> [inc] [1 10 50])" "(ap [inc] [1 10 50])" "(ap [inc (partial * 100)] [1 10 50])" "(doc r/map)" "(source r/map)" "r/map" "(require '[clojure.core.reducers \:as r])" "(doc r/map)" "(source r/map)" "(r/mapcat [[1] [2] [3]])" "(into [] (r/mapcat [[1] [2] [3]]))" "(into [] (r/mapcat inc [[1] [2] [3]]))" "(into [] (r/mapcat \#([inc %]) [[1] [2] [3]]))" "(into [] (r/mapcat \#([inc %]) [1 2 3]))" "(doc r/mapcat)" "(doc mapcat)" "(into [] (r/mapcat \#(vec (inc %)) [1 2 3]))" "(mapcat \#(vec (inc %)) [\\n                        1 2 3]))" "(map \#(vec (inc %)) [1 2 3]))" "(map inc [1 2 3])" "(into [] (r/mapcat \#(vector (inc %)) [1 2 3]))" "(source r/mapcat)" "(doc folder)" "(doc r/folder)" "(r/folder (r/mapcat \#(vector (inc %)) [1 2 3]))" "(r/folder [1 2 3] (r/mapcat \#(vector (inc %))))" "(doc r/map)" "(source r/map)" "(source r/mapcat)" "(def v (vec (take 1000000 (iterate inc 0))))" "(defn f [x] (vector (inc x)))" "(time (count (bind f v)))" "(time (count (>>\= f v)))" "(time (count (>>\= [f] v)))" "(time (count (>>\= [inc] v)))" "(p/bind [inc] [1 2 3])" "(time (count (>>\= v [inc])))" "(time (count (>>\= v f)))" "(f 1)" "(time (count (r/mapcat f v)))" "(time (count (into [] (r/mapcat f v))))" "(def v1 (bind v f))" "(def v1 (p/bind v f))" "(time (count (join v1)))" "(time (count (p/join v1)))" "(first v1)" "(def v1 (fmap f v))" "(time (count (p/join v1)))" "(time (count (into [] (r/mapcat identity v1))))" "(time (count (p/join v1)))" "(time (take 10 (p/join v1)))" "(source r/mapcat)" "(time (count (p/join v1)))" "(time (count (flatten v1)))" "(time (count (r/flatten v1)))" "(first v1)" "(time (count (r/foldcat v1)))" "(append\! v1 [\:d])" "(r/append\! v1 [\:d])" "(r/flatten [[1] [2]])" "(into [] (r/flatten [[1] [2]]))" "(time (count (into [] (r/flatten v1))))" "(time (count (p/join v1)))" "(flatten v1)" "(time (count (flatten v1)))" "(time (count (into [] (r/mapcat f v))))" "(time (count (into [] (p/bind v f))))" "(time (count (p/bind v f)))" "(time (count (join v f)))" "(time (count (join f v)))" "(time (count (p/join f v)))" "(time (count (p/join v)))" "(first v)" "v" "(first v)" "(first v1)" "(time (count (p/join v1)))" "(time (count (into [] (r/mapcat f v1))))" "(f 1)" "(time (count (into [] (r/mapcat f v))))" "(time (count (p/join v1)))" "(time (count (into [] (r/mapcat f v))))" "(time (count (p/join v1)))" "(time (count (p/bind v1 f)))" "(f 1)" "(fmap [1 2] f)" "(p/fmap [1 2] f)" "(time (count (p/bind v f)))" "(time (count (p/fmap v f)))" "(time (count (p/bind v f)))" "(into [] (r/mapcat \#(r/map % [1 2 3]) [inc (partial * 100)]))" "(time (count (into [] (r/mapcat \#(r/map % v) [inc (partial * 100)]))))" "(time (count (<*> [inc (partial * 100)] v))))" "(time (count (p/<*> [inc (partial * 100)] v))))" "(time (count (p/<*> [inc (partial * 100)] v)))" "(time (count (into [] (r/mapcat \#(r/map % v) [inc (partial * 100)]))))" "(time (count (p/<*> [inc (partial * 100)] v)))" "p" "(time (count (p/<*> [inc (partial * 100)] v)))" "(time (count (into [] (r/reduce conj (r/reduce conj \#( % v) [inc (partial * 100)]))))" "(doc r/reduce)" "(map \#(%1 %2) [inc] [1 2])" "(time (count (map \#(%1 %2) [inc] v)))" "(time (count (map \#(%2 %1) v [inc])))" "(doc reduce)" "(doc r/mapcat)" "(foldmap [1 2] inc)" "(p/foldmap [1 2] inc)" "(r/map [1 2] inc)" "(into [] (r/map [1 2] inc))" "(p/foldmap [1 2] inc)" "(r/map [1 2] inc)" "(doc r/map)" "(r/map inc [1 2])" "(into [] (r/map inc [1 2]))" "(r/fold (into [] (r/map inc [1 2])))" "(fold (into [] (r/map inc [1 2])))" "(fold (r/map inc [1 2]))" "(doc extend)" "(doc defprotocol)" "(find-doc \\"alias\\")" "(pure [] 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "(pure [] 1)" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(pure [] 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "(pure 1 [])" "pure" "(pure 1 1)" "(pure [1] 1)" "(p/pure [1] 1)" "(def pure1 p/pure)" "(pure1 [1] 1)" "(pure1 [] 1)" "(pure [] 1)" "(pure 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "pure" "(def pure p/pure)" "(pure [] 1)" "(doc mapcat)" "*ns*" "(<*> (pure (lazy-seq [1]) inc) (lazy-seq [1 2 3]))" "(<*> (pure [1] inc) [1 2 3])" "(<*> inc (partial * 100))" "(doc butlast)" ";; Switching to clojure.core.reducers namespace" "(defcurried myfn \\"\\" {} [x y] (+ x y))" "myfn" "(myfn 1 2)" "(myfn 1)" "((myfn 1) 2)" "(macroexpand '(defcurried myfn \\"\\" {} [x y] (+ x y)))" "(macroexpand '(defcurried myfn \\"\\" {} [x y z] (+ x y)))" "(defcurried myfn \\"\\" {} [x y z] (+ x y z))" "(myfn 1)" "(+ 3 nil)" "(<*> [+] [3])" ";; Switching to org.uncomplicate.redcat.core namespace" "(<*> [+] [3])" "((<*> [+] [3]) [4])" "(<*> [+] (<*> [+] [3]) [4])" "(concat [1 2] [3 4])" "(<*> [concat] [1 2] [3 4])" "(source map)" ";; Switching to org.uncomplicate.redcat.core namespace" "(defn ex [x y & zs] (+ x y @zs))" "(ex 1 2 3)" "(defn ex [x y & zs] (apply + x y zs))" "(ex 1 2 3)" "(ex 1 2 3 4)" "(ex 1 2 3 4 5)" "(<*> + nil 1 2 3)" "(<*> + nil 1)" "(<*> + nil\\n     )" "(<*> + nil 1)" "(<*> + nil\\n     \\n     )" "(<*> + nil 1)" "(<*> + nil 1 2 3)" "(time (count (<*> [+] (vec (take 1000000 (iterate inc 0))) (vec (take 1000000 (iterate inc 0))))))" "(time (count (<*> [+] (vec (take 1000000 (iterate inc 0))))))" "(<*> [inc] [1 2 3])" "(partial inc)" "(partial inc 1)" "((partial inc 1))" "(fmap + [1 2] '(3 4))" "(fmap + [1 2] '(3 4 5))" "(fmap + (fmap + [3 4]))" "(fmap (comp + *) [3 4] [5 6 7])" "(fmap + (fmap * [3 4] [5 6 7])" "(fmap + (fmap * [3 4] [5 6 7]))" "(fmap inc (fmap * [3 4] [5 6 7]))" "(fmap (comp inc *) [3 4] [5 6 7]))" "(fmap (comp inc *) [3 4] [5 6 7])" "(inc 1 2)" "(fmap + [1 2] [10 20])" "(<*> [+] [1 2] [10 20])" "(<*> [+ \= * /] [1 2] [10 20])" "(<*> [+ - * /] [1 2] [10 20])" "(count (r/map inc (take 100000000 (iterate inc 1))))" "*ns*" "(require '[clojure.core.reducers \:as r]))" "(count (r/map inc (take 100000000 (iterate inc 1))))" "(count (into [] (r/map inc (take 100000000 (iterate inc 1)))))" "(source vec)" "(fmap partial *)" "(<*> ((fmap partial *) [2 5 10]) [8 10 11])" "(<*> ((fmap (comp partial *)) [2 5 10]) [8 10 11])" "(comp partial *)" "(<*> [inc dec *] [1 2 3] [4 5 6])" "(map + {\:a 1 \:b 2} {\:c 3 \:d 4})" "(map vector {\:a 1 \:b 2} {\:c 3 \:d 4})" "(fmap + {\:a 1 \:b 2} {\:c 3 \:d 4})" "(fmap + {\:a 1 \:b 2})" "(fmap inc {\:a 1 \:b 2})" "(fmap inc [1 2])" "(fmap inc {\:a 1 \:b 2})" "(fmap inc (first {\:a 1 \:b 2}))" "(fmap \#(fmap inc) (first {\:a 1 \:b 2}))" "(fmap (fmap inc) (first {\:a 1 \:b 2}))" "(fmap (fmap inc) {\:a 1 \:b 2})" "(fmap (fmap inc) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap +)" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2})" "(apply fmap + {\:a 1 \:b 2})" "(fmap inc {\:a 1 \:b 2})" "(fmap inc (first {\:a 1 \:b 2}))" "(fmap inc (first {\:a 1 \:b 2}) [3 4])" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "((fmap +) 1 2)" "((fmap inc) 1)" "((fmap +) 1 2)" "(fmap + 1 2)" "((fmap +) 1 2)" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) [[1] [2]] [[3] [5]])" "(map + {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap + {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap \#(+ (val %1) (val % 2)) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap \#(+ (val %1) (val %2)) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(map (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "((fmap +) (first {\:a 1 \:b 2}) (first {\:c 3 \:d 5}))" "(first {\:a 1 \:b 2})" "(apply + 1)" "((fmap +) (first {\:a 1 \:b 2}) (first {\:c 3 \:d 5}))" "(map (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(fmap (fmap +) {\:a 1 \:b 2} {\:c 3 \:d 5})" "(+ nil 3)" "(fmap + nil 3)" "(source +)" "(source cast)" "(doc reduce1)" "(extend-type +\\n  Functor\\n  (fmap [f x y] f x y))" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(extend-type +\\n  Functor\\n  (fmap [f x y] f x y))" "(type +)" "(extend-type clojure.core$_PLUS_\\n  Functor\\n  (fmap [f x y] f x y))" "(+ 1 2)" "(and 1 nil 2)" "(if (some nil? [1 2 3]) nil \:a)" "(if (some nil? [1 2 nil]) nil \:a)" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap + 1 2)" "(fmap + 1 nil)" "(+ 1 nil)" ";; Switching to org.uncomplicate.redcat.core namespace" "(require 'org.uncomplicate.redcat.jvm)" "  (require '[clojure.core.reducers \:as r])" "(doc r/fold)" "(r/fold + [1 2 3])" "(def v (vec (take 1000000 (iterate inc 0))))" "(time (r/reduce + v))" "(time (r/fold + v))" "(r/fold + v)" "  (require '[clojure.core.reducers \:as r] \:reload)" "(r/fold + v)" "(source require)" "(source loadf-libs)" "(source load-libs)" "(doc load-file)" "(load-file \\"clojure.core.reducers.clj\\")" "(load-file \\"clojure/core/reducers.clj\\")" "*ns*" "(doc name)" "(load-file \\"../clojure/core/reducers.clj\\")" "(load-file \\"./clojure/core/reducers.clj\\")" "(load-file \\"core.clj\\")" "\\n  (import 'java.io.File)" "\\n(defn my-ls [d]\\n  (println \\"Files in \\" (.getName d))\\n  (doseq [f (.listFiles d)]\\n    (if (.isDirectory f)\\n      (print \\"d \\")\\n      (print \\"- \\"))\\n    (println (.getName f))))" "(my-ls (File. \\".\\"))" "  (require '[clojure.core.reducers \:as r] \:reload-all)" "(r/fold + v)" ";; Switching to org.uncomplicate.redcat.core namespace" "  (require '[clojure.core.reducers \:as r])" "(r/fold + v)" "(def v (vec (take 1000000 (iterate inc 0))))" "(time (r/reduce + v))" "(time (r/fold + v))" "(def v (vec (take 10000000 (iterate inc 0))))" "(time (r/fold + v))" "(time (r/reduce + v))" "(time (r/fold + v))" "(time (r/reduce + v))" "(time (count (fmap inc v)))" "(time (count (fmap inc (fmap dec v))))" "(time (count (fmap inc v)))" "(time (count (fmap (comp inc dec) v)))" "(time (count (fmap inc (fmap dec v))))" "(time (count (comp (fmap inc) (fmap dec)) v))" "(time (count ((comp (fmap inc) (fmap dec)) v)))" "((fmap inc dec inc) 1)" "((fmap inc dec) 1)" "((comp inc dec) 1)" "((fmap inc dec) 1)" "(fmap inc dec)" "(fmap (fmap inc dec) 1)" "(fmap inc 1)" "(fmap (comp inc dec) 1)" "(fmap (fmap inc dec) 1)" "((fmap inc dec) 1)" "(isa? inc clojure.lang.Fn)" "(isa? (type inc) clojure.lang.Fn)" "(type inc)" "(ancestors inc)" "(parents inc)" "(ancestors (type inc))" "\\n(fmap inc dec)" ";; Switching to org.uncomplicate.redcat.core namespace" "\\n(fmap inc dec)" ";; Switching to org.uncomplicate.redcat.core namespace" "\\n(fmap inc dec)" "(doc comp)" ";; Switching to org.uncomplicate.redcat.core namespace" "1" "(doc comp)" "(source comp)" "(comp inc dec)" "((comp inc dec dec) 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "((comp inc dec dec) 1)" "(doc comp)" "(use 'clojure.repl)" "(doc comp)" "((comp inc dec dec) 1)" "((fmap inc dec dec) 1)" "((fmap inc dec) 1)" "(fmap inc dec)" "*ns*" "(fmap inc dec)" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap inc dec)" "((fmap inc dec) 1)" "((fmap inc dec) 1 2)" "((fmap inc\\n       ) 1 2)" "(fmap [(fmap inc dec)] [1])" "(fmap inc dec)" "(comp inc dec)" "(def a (comp inc dec))" "a" "(fmap inc dec)" "(a 1)" "(def b (fmap inc dec))" "(b 1)" "((fmap inc dec inc) 1)" "((fmap inc dec) 1)" "(b 1)" "(def c (fmap inc dec))" "(c 1)" "(b 1)" "((fmap inc dec dec) 1)" "(fmap inc dec inc)" "(def d (fmap inc dec inc))" "(d 1)" "((fmap inc dec) 1\\n                )" "((fmap inc dec dec) 1)" "((apply comp inc dec [dec]) 1)" "((fmap inc dec dec) 1)" "((fmap inc) 1)" "((fmap inc) dec)" "((fmap inc) [1])" "((fmap inc) dec)" "(p/fmap inc)" "((fmap inc) [1])" "((fmap inc dec) [1])" "(fmap inc dec)" "((fmap inc) [1])" "*ns*" ";; Switching to org.uncomplicate.redcat.core namespace" "((fmap inc) [1])" "((fmap inc dec) [1])" "((fmap inc dec) 1)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.uncomplicate.redcat.jvm)))" "*ns*" "((fmap inc dec) 1)" "(ancestors dec)" "(fmap inc [1])" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap inc [1])" "((fmap inc dec) 1)" ";; Switching to org.uncomplicate.redcat.core namespace" "((fmap inc dec) 1)" "(fmap inc dec)" "((apply comp inc dec [dec]) 1)" "((comp inc dec dec) 1)" "(fmap inc dec)" "((fmap inc dec) 1)" "((fmap inc dec dec) 1)" "((fmap inc dec) 1)" "(((partial comp inc) dec) 1)" "(((partial (partial comp inc) dec) dec) 1)" "(time (count (fmap inc (fmap dec v))))" "(def v (vec (take 10000000 (iterate inc 0))))" "(source take)" "(use 'clojure.repl)" "doc" "(source take)" "(source vec)" "(time (count (fmap inc (fmap dec v))))" "(time (count (fmap inc dec) v))" "(time (count (fmap (fmap inc dec) v)))" "(r/fold conj (r/map inc v))" "\\n  (require '[clojure.core.reducers \:as r]))" "(r/fold conj (r/map inc v))" "(doc r/fold)" "(conj)" "(+)" "(doc conj)" "(source into)" "(partial crate-combinef [1])" ";; Switching to org.uncomplicate.redcat.jvm namespace" "(partial crate-combinef [1])" "(partial create-combinef [1])" "((partial create-combinef [1]))" "((partial create-combinef [1]) [2])" "(doc r/monoid)" "((monoidalf 1))" "((monoidalf 1) 2 3)" "(ccw.debug.serverrepl/with-exception-serialization (clojure.core/binding [clojure.core/*compile-path* \\"classes\\"] (clojure.core/compile 'org.uncomplicate.redcat.jvm)))" "(fold [1 2 3])" "(time (fold v))" "(def v (vec (take 10000000 (iterate inc 0))))" "(time (fold v))" "(time (reduce + v))" "(time (fold v))" "(time (r/reduce + v))" "(time (fold v))" "(time (r/reduce (monoidalf 1) v))" "(def v1 (fmap vector v))" "(time (fold v1))" "(first v1)" "(def v1 (fmap vector [1 2 3]))" "(first v1)" "(vector 1)" "(def v1 (fmap vector [1 2 3]))" "v1" "(fmap inc [1 2 3])" "(extend clojure.lang.PersistentVector\\n  Functor\\n  {\:fmap coll-fmap})" "(fmap inc [1 2 3])" "(extend-type clojure.lang.Fn\\n  Functor)" "(fmap inc [1 2 3])" "*ns*" "(fmap inc [1 2 3])" "(extend-type clojure.lang.Fn\\n  Functor)" "(fmap inc [1 2 3])" "*ns*" "fmap" "(fmap inc [1 2 3])" ";; Switching to org.uncomplicate.redcat.core namespace" "(fmap inc [1 2 3])" "(def v (vec (take 10000000 (iterate inc 0))))" "\\n  (require '[clojure.core.reducers \:as r])" "(def v1 (fmap vector v))" "(first v1)" "(time (fold v1))" "fold" "(fold [1 2 3])" "*ns*" "(p/fold [1 2 3])" "(fold [1 2 3])" "*ns*" "(time (fold v1))" "(def v1)" ";; Switching to org.uncomplicate.redcat.core namespace" "(def v (vec (take 10000000 (iterate inc 0))))" "(def v (vec (take 1000000 (iterate inc 0))))" "(def v1 (fmap vector v))" "(time (fold v1))" "(first v1)" "(time (count (fold v1)))" "\\n  (require '[clojure.core.reducers \:as r])" "(time (count (r/reduce into v1)))" "(time (count (reduce into v1)))" "(time (count (r/reduce into [] v1)))" "(time (count (fold v1)))" "(time (count (r/fold (monoidalf []) v1)))" "(time (count (r/fold (p/monoidalf []) v1)))" "(time (count (into [] (r/map inc v))))" "(time (count (r/fold (monoidalf []) (r/map inc v))))" "(time (count (r/fold (p/monoidalf []) (r/map inc v))))" "p" "*ns*" "  (require '[org.uncomplicate.redcat.jvm \:as j]))" "(time (count (r/fold (j/monoidalf []) (r/map inc v))))" "(time (count (r/fold (j/monoidalf []) (r/monoid conj vector) (r/map inc v))))" "(time (first (r/fold (j/monoidalf []) (r/monoid conj vector) (r/map inc v))))" "(time (count (fmap inc v)))" "(time (count (fmap vector v)))" "p" "(time (count (fmap vector v)))" "(time (first (r/fold (j/monoidalf []) (r/map vector v))))" "(time (count (fmap inc (fmap dec v))))" "(time (count (fmap (fmap inc dec) v)))" "(def v (range 10000000))" "(time (count (fmap (fmap inc dec) v)))" ";; Switching to org.uncomplicate.redcat.core namespace" "  (require '[org.uncomplicate.redcat.jvm \:as j])" "\\n  (require '[clojure.core.reducers \:as r])" "(def v (range 10000000))" "(time (count (fmap (fmap inc dec) v)))" "1" ";; Switching to org.uncomplicate.redcat.core namespace" "(def v (range 10000000))" "(time (fold v))" ";; Switching to org.uncomplicate.redcat.core namespace" "\\n  (require '[clojure.core.reducers \:as r])" "(def v (range 10000000))" "(time (fold v))" "8ns*" "*ns*" "(time (fold v))" "(time (count (fmap (fmap inc dec) v)))" "(time (count (fmap dec (fmap inc v)))\\n      )" "(str \\"kk\\" nil)" "((partial str \\"aa\\") \\"kk\\")" "(partial fmap + [1 2 3])" "((partial fmap + [1 2 3]) [4 5 6])" "(-> [1 2 3] reverse conj 4)" "(-> [1 2 3] reverse (conj 4))" "(-> [1 2 3] (fmap reverse) (conj 4))" "(-> [1 2 3] (p/fmap reverse) (conj 4))" "(-> [1 2 3] (p/fmap reverse) )" "(-> [1 2 3] inc (conj 4))" "(-> [1 2 3] count (+ 1))" "(-> [1 2 3] (partial fmap reverse) )" "(-> [1 2 3] (p/fmap reverse) )" "(p/fmap [1 2 3] reverse)" "(-> [1 2 3] (p/fmap inc) )" "(-> [1 2 3] (fmap inc) )" "(-> [1 2 3] (fmap inc) apply)" "(->> [1 2 3] (famp inc) (fmap dec) (fmap inc))" "(->> [1 2 3] (fmap inc) (fmap dec) (fmap inc))" "(<*> [1 2] [3 4])" "(into [] 3)" "(->> [1 2 3] (fmap inc) (fmap dec) (fmap (partioal * 100)))" "(->> [1 2 3] (fmap inc) (fmap dec) (fmap (partial * 100)))" "(->> [1 2 3] (fmap inc) (fmap inc) (fmap (partial * 100)))" "((<*> (partial + 3) (partial * 100)) 5)" "(<*> [inc] [1 2 3])" "(<*> comp inc dec dec)" "(partial comp)" "(comp inc)" "((comp inc) 1)" "(partial comp)" "((partial comp) inc)" "(((partial comp) inc) 1)" "(((partial comp) inc) dec)" "(fmap inc)" "(fmap inc 1)" "((fmap inc) dec)" "(((fmap inc) dec) 1)" "(((fmap inc) (partial * 100)) 1)" "((((fmap comp) inc) dec) 1)" "((partial + 1 2))" "((((fmap comp) inc) dec) 1)" "(comp inc dec)" "((comp inc dec) 1)" "(((comp inc dec) dec) 1)" "((((fmap comp) inc) dec) 1)" "(-> (fmap comp) inc dec 1)" "((-> (fmap comp) inc dec) 1)" "((-> (fmap comp) inc dec))" "(-> (fmap comp) inc dec)" "(->> (fmap comp) inc dec)" "(fmap comp)" "((fmap comp) inc)" "(((fmap comp) inc) 1)" "((((fmap comp) inc)) 1)" "(-> (fmap inc) inc dec 1)" "((-> (fmap inc) inc dec) 1)" "(fmap inc)" "((fmap inc) 1)" "(((fmap inc) dec) 1)" "((((fmap comp) inc) dec) 1)" "(((((fmap comp) inc) dec) dec) 1)" "(((((fmap inc) dec) dec) 1)" "((((fmap inc) dec) dec) 1)" "(((((fmap inc) dec) dec) dec) 1)" "((((((fmap inc) dec) dec) dec)) 1)" "    (let [u [(partial * 2)]\\n        v [(partial + 100)]\\n        w [1 2 3]]\\n[(-> \#(partial comp %) (fmap u) (fmap v) (fmap w)) (fmap u (fmap v w))])" "(let [u [(partial * 2)]\\n      v [(partial + 100)]\\n      w [1 2 3]]\\n  (vector (-> \#(partial comp %) (fmap u) (fmap v) (fmap w)) (fmap u (fmap v w))))" "(let [u [(partial * 2)]\\n      v [(partial + 100)]\\n      w [1 2 3]]\\n  '((-> \#(partial comp %) (fmap u) (fmap v) (fmap w)) (fmap u (fmap v w))))" "(let [u [(partial * 2)]\\n      v [(partial + 100)]\\n      w [1 2 3]]\\n  (list (-> \#(partial comp %) (fmap u) (fmap v) (fmap w)) (fmap u (fmap v w))))" "(let [u (partial * 2)\\n      v (partial + 100)\\n      w [1 2 3]]\\n  (list (-> \#(partial comp %) (fmap u) (fmap v) (fmap w)) (fmap u (fmap v w))))" "(partial comp)" "((partial comp) inc)" "(((partial comp) inc) dec)" "(-> (pure \\"a\\" \#(partial str %)) (<*> \\"johntra\\") (<*> volta))" "(-> (pure \\"a\\" \#(partial str %)) (<*> \\"johntra\\") (<*> \\" volta\\"))" "(fmap str \\"johntra\\" \\"volta\\")" "(fmap str \\"johntra\\")" "(fmap str \\"johntra\\" \\"volta\\")" "(str)" "(op \\"aa\\" \\"bb\\")" "*ns*" "(fold [\\"aa\\" \\"bb\\"])" "(fold [\\"aa\\" \\"bb\\" nil])" "(fold [nil \\"aa\\" \\"bb\\"])" "(apply str [nil \\"aa\\" \\"bb\\"])" "(+ nil 1 2)" "(fold + [nil 1 2])" "(fold [nil 1 2])" "(macroexpand '(applicative-law2-composition (gen/one-of [inc] [(partial * 10)]) (gen/vec (gen/int))))" "(applicative-law2-composition (gen/one-of [inc] [(partial * 10)]) (gen/vec (gen/int)))" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(macroexpand '(applicative-law2-composition (gen/one-of [inc] [(partial * 10)]) (gen/vec (gen/int))))" "(pure [] [1 2])" "*ns*" "1" "InstantiationError" "(*ns*)" "(ns org.uncomplicate.redcat.core)" "*ns*" "(pure [] [1 2])" "$" "(defn $ [y] \#(% y))" "($ 10)" "(($ 10) inc)" "((juxt inc dec (partial * 100) 1)" "((juxt inc dec (partial * 100) 1))" "((juxt inc dec (partial * 100)) 1)" "(<*> [inc dec (*partial * 100)] [1])" "(<*> [inc dec (partial * 100)] [1])" "((juxt + * /) [1 2 3 4])" "((juxt + * /) 1 2 3 4)" "(($ 1 2 3 4) /)" "(($ 1 2 3 4 5) /)" "(($ 1 2 3 4 5) *)" "(type (list))" "(fmap inc [1 2 3])" "(fmap inc (list 1 2 3))" "(<*> (pure (list) inc) (list 1 2 3))" "(gen/list)" "  (require '[clojure.data.generators \:as gen])" "(gen/list)" "(gen/list (gen/int)\\n          )" "(gen/list (gen/int))" "(gen/vec (gen/int))" "(reps 10 (gen/int))" "  (require '[clojure.data.generators \:as gen])" "(gen/reps 10 (gen/int))" "(gen/int)" "(repeatedly 10 (gen/int))" "(repeatedly 10 gen/int)" "(gen/vec gen/int)" "(gen/vec gen/string)" "(\\n  (partial gen/vec gen/string))" "gen-fn" ";; Switching to org.uncomplicate.redcat.core-test namespace" "gen-fn" "(gen-fn inc (partial * 100))" "((gen-fn inc (partial * 100)))" "((gen-fn inc (partial * 100)) 1)" "(def a (gen-fn inc (partial * 100))" "(def a (gen-fn inc (partial * 100)))" "(a 1)" "(defn gen-fn [& fs]\\n  \#(first (apply gen/one-of (map vector fs))))" "(def a (gen-fn inc (partial * 100)))" "((a) 1)" "(gen/list gen/int)" "(gen-fn s/capitalize s/lower-case s/upper-case s/reverse)" "((gen-fn s/capitalize s/lower-case s/upper-case s/reverse))" "(functor-law2 (gen-fn s/capitalize s/lower-case s/upper-case s/reverse) gen/string)" "(first {})" "(formula \\"\\" [1] \=> [1])" "(formula \\"\\" [] [1] \=> [1])" "(formula \\"\\" [x 1] [1] \=> [1])" "(formula \\"\\" [x 2] [x] \=> [1])" "(formula (str \\"\\" \\"p\\") [x 2] [x] \=> [1])" "(formula (apply str \\"\\" \\"p\\") [x 2] [x] \=> [1])" "(fact (str \\"\\" \\"o\\") [1] \=> [1])" "(fact (str \\"\\" \\"o\\") [1] \=> [2])" "(let [dosc (str \\"\\" \\"p\\")]\\n(formula docs [x 2] [x] \=> [1]))" "(let [dosc (str \\"\\" \\"p\\")]\\n  (println docs)\\n  \\n(formula docs [x 2] [x] \=> [1]))" "(let [dosc (str \\"\\" \\"p\\")]\\n  (println docs))\\n  \\n(formula docs [x 2] [x] \=> [1]))" "(let [dosc (str \\"\\" \\"p\\")]\\n  (println docs))" "(let [d (str \\"\\" \\"p\\")]\\n  (println d))" "(let [d (str \\"\\" \\"p\\")]\\n  (println d\\n           )\\n  \\n(formula d [x 2] [x] \=> [1]))" "(<*> (pure [] inc) [1 2])" "(<*> (pure (gen-vec gen-int) inc) [1 2])" "(<*> (pure (gen/vec gen-int) inc) [1 2])" "(<*> (pure (gen/vec gen/int) inc) [1 2])" "(formula \\"First applicative law.\\"\\n            [f gen-fn inc (partial * 10)\\n             x\# (gen/vec gen/int)]\\n            (<*> (pure x\# f\#) x\#) \=> (fmap f\# x\#))" "(formula \\"First applicative law.\\"\\n            [f\# gen-fn inc (partial * 10)\\n             x\# (gen/vec gen/int)]\\n            (<*> (pure x\# f\#) x\#) \=> (fmap f\# x\#))" "(formula \\"First applicative law.\\"\\n            [f  gen-fn inc (partial * 10)\\n             x (gen/vec gen/int)]\\n            (<*> (pure x  f) x) \=> (fmap f x))" "(formula \\"First applicative law.\\"\\n            [f  gen-fn inc (partial * 10)\\n             x (gen/vec gen/int)]\\n            (<*> (pure x  f) x) \=> (fmap f []))" "(formula \\"First applicative law.\\"\\n            [f  gen-fn inc (partial * 10)\\n             x (gen/vec gen/int)]\\n            (<*> (pure x  f) x) \=> (fmap f x))" "(formula \\"First applicative law.\\"\\n            [f  (gen-fn inc (partial * 10))\\n             x (gen/vec gen/int)]\\n            (<*> (pure x  f) x) \=> (fmap f x))" "(formula \\"First applicative law.\\"\\n            [f  (gen-fn inc (partial * 10))\\n             x (gen/vec gen/int)]\\n            (<*> (pure x  f) x) \=> (fmap f []))" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/list (gen/int)))" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/vec gen/int))" "(applicative-law2-identity (gen/vec gen/int))" "(applicative-law3-composition (gen/one-of [inc] [(partial * 10)]) (gen/vec gen/int))" "(applicative-law4-homomorphism (gen/vec gen/int) (gen-fn inc (partial * 10)) (gen/int))" "(applicative-law5-interchange (gen/vec gen/int) (gen-fn inc (partial * 10)) (gen/int))" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/list (gen/int)))" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/list gen/int))" "(<*> (pure (gen/vec gen/int) inc) [1 2])" "(<*> (pure (gen/vec gen/int) inc) '(1 2))" "(empty '(3 2))" "(type \\n  (empty '(3 2)))" "(isa? (type \\n  (empty '(3 2))) clojure.lang.IPersistentCollection)" "(into\\n  (empty '(3 2)) [1 2])" "(conj\\n  (empty '(3 2)) [1 2])" "(conj\\n  (empty '(3 2)) 1)" "(type '())" "(fmap inc '(1 2))" "(pure '() inc)" "(<*> (pure '() inc) '(1))" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/vec gen/int))" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/list gen/int))" "(empty '())" "(conj (empty '() 1)" "(conj (empty '() 1))" "(conj (empty '()) 1)" "(<*> (pure (gen/list gen/int) inc) '(1 2))" "(pure (gen/list gen/int) inc)" "pure" "(gen/list gen/int)" "(def av (gen/list gen/int))" "av" "(pure av inc)" "((pure av inc) 1)" "(pure av inc)" "(lazy-seq (list v))" "find-ns" "(lazy-seq [])" "(lazy-seq (list 1))" "(def v 1)" "(def jv 1)" "jv" "(lazy-seq (list jv))" "jv" "(def jv '(jv))" "jv" "(pure jv 1)" "(pure jv inc)" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/list gen/int))" "(<*> (pure (gen/list gen/int) inc) '(1 2))" "(pure (gen/list gen/int) inc)" "(pure (list) inc)" "(pure (gen/list gen/int) inc)" "(pure (gen/set gen/int) inc)" "(pure (gen/list\\n        gen/int) inc)" "(def lazy-seq (lazy-seq))" "(def lazy-seq (lazy-seq [1 2]))" "(def laz (lazy-seq (lazy-seq [1 2])))" "lazy-seq" "(lazy-seq [1])" ";; Switching to org.uncomplicate.redcat.core-test namespace" "(lazy-seq [1])" "(use 'clojure.core)" "(lazy-seq [1])" "(def laz (lazy-seq (lazy-seq [1 2])))" "(type laz)" "(type conj laz 1)" "(type (conj laz 1))" "(isa? (type (conj laz 1)) clojure.lang.LazySeq)" "laz" "(isa? (type (conj laz 1)) clojure.lang.LazySeq)" "(isa? (type (lazy-seq laz)) clojure.lang.LazySeq)" "(type (gen/list gen/vec))" "(type (list 1 2))" "(type (apply list (gen/list gen/vec)))" "(type (apply list (gen/list gen/int)))" "(type (gen/list gen/int))" "(applicative-law1 (gen-fn inc (partial * 10)) \#(apply list (gen/list gen/int)))" "(applicative-law1 (gen-fn inc (partial * 10)) (gen/list gen/int))" "(applicative-law1 (gen-fn inc (partial * 10)) \#(gen/list gen/int))" "(applicative-law1 (gen-fn inc (partial * 10)) (fn [] (apply list (gen/list gen/int))))" "(applicative-law1 (gen-fn inc (partial * 10)) (list 1 2 333 443435 544544 -43434))" "(applicative-law2-identity \#(apply list (gen/list (gen/int))))" "(type (list [1 2]))" "(applicative-law2-identity (apply list (gen/list (gen/int))))" "(applicative-law3-composition (gen/one-of (list inc) (list (partial * 10))) \\n                              (apply list (gen/list (gen/int))))" "(applicative-law4-homomorphism (apply list (gen/list (gen/int)))\\n                               (gen-fn inc (partial * 10)) (gen/int))" "(applicative-law5-interchange (apply list (gen/list (gen/int)))\\n                              (gen-fn inc (partial * 10)) (gen/int))" "(applicative-law1 (gen-fn inc (partial * 10)) (apply list (gen/list (gen/int))))" "(functor-law2 (gen-fn (partial * 100) inc) (lazy-seq (gen/list gen/int)))" "(fmap-keeps-type inc (lazy-seq (gen/list gen/int)))" "(functor-law2 (gen-fn (partial * 100) inc) (seq (gen/list gen/int)))" "(seq (gen/list gen/int))" "(type (seq (gen/list gen/int)))" "(def s (seq (lazy-seq [1 2 3])))" "(type s)" "(def s (seq (list 1 2 3)))" "(type s)" "(type (gen/list gen/int))" "(fmap inc [1 2 3])" "(fmap inc (list 1 2 3))" "(functor-law2 (gen-fn (partial * 100) inc) (gen/list gen/int))" "(fmap (comp inc dec) (list 1 2 3))" "(fmap inc (fmap dec) (list 1 2 3))" "(functor-law2 (gen-fn (partial * 100) inc) (gen/list gen/int))" "(fmap inc (fmap dec (list 1 2 3))" "(fmap inc (fmap dec (list 1 2 3)))" "(\= (fmap inc (fmap dec) (list 1 2 3))\\n   (fmap inc (fmap dec (list 1 2 3))))" "(functor-law2 (gen-fn (partial * 100) inc) (gen/list gen/int))" "(functor-law2 (gen-fn (partial * 100) inc) (seq (gen/list gen/int)))" "(def l (gen/list gen/int))" "l" " (\= (fmap (comp inc  (*partial * 100)) l) (fmap inc (fmap (*partial * 100) x\#))" " (\= (fmap (comp inc  (*partial * 100)) l) (fmap inc (fmap (*partial * 100) x\#)))" " (\= (fmap (comp inc  (*partial * 100)) l) (fmap inc (fmap (partial * 100) x\#)))" " (\= (fmap (comp inc  (partial * 100)) l) (fmap inc (fmap (partial * 100) x\#)))" " (\= (fmap (comp inc  (partial * 100)) l) (fmap inc (fmap (partial * 100) l)))" "(fmap (comp inc  (partial * 100)) l)" " (fmap inc (fmap (partial * 100) l))" "(fmap (comp inc  (partial * 100)) (seq l))" " (fmap inc (fmap (partial * 100) (seq l)))" "(seq l)" "l" "(type l)" "(type (seq l))" "(fmap inc l)" "(fmap inc (seq l)\\n      l)" "(fmap inc (seq l)\\n      )" "(ancestors clojure.lang.Cons)" "(map inc l)" "l" "(map inc (seq l))"]
eclipse.preferences.version=1
