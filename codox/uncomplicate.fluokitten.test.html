<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.fluokitten.test documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Fluokitten 0.2.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="uncomplicate.fluokitten.core.html"><span>uncomplicate.fluokitten.core</span></a></li><li><a href="uncomplicate.fluokitten.jvm.html"><span>uncomplicate.fluokitten.jvm</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html"><span>uncomplicate.fluokitten.protocols</span></a></li><li class="current"><a href="uncomplicate.fluokitten.test.html"><span>uncomplicate.fluokitten.test</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="uncomplicate.fluokitten.test.html#var-applicative-law1"><span>applicative-law1</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-applicative-law2-identity"><span>applicative-law2-identity</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-applicative-law3-composition"><span>applicative-law3-composition</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-applicative-law4-homomorphism"><span>applicative-law4-homomorphism</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-applicative-law5-interchange"><span>applicative-law5-interchange</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-check-eq"><span>check-eq</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-data-structures-should-preserve-metadata"><span>data-structures-should-preserve-metadata</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-fapply-keeps-type"><span>fapply-keeps-type</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-fmap-keeps-type"><span>fmap-keeps-type</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-functor-law2"><span>functor-law2</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-magma-op-keeps-type"><span>magma-op-keeps-type</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-monad-law1-left-identity"><span>monad-law1-left-identity</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-monad-law2-right-identity"><span>monad-law2-right-identity</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-monad-law3-associativity"><span>monad-law3-associativity</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-monoid-identity-law"><span>monoid-identity-law</span></a></li><li><a href="uncomplicate.fluokitten.test.html#var-semigroup-op-associativity"><span>semigroup-op-associativity</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>uncomplicate.fluokitten.test documentation</h2><pre class="doc">Macros that generate Midje tests for various laws that
categorical concepts have to satisfy. You should use these tests
to check if your implementations of clojure protocols are valid
beyond what the compiler can assert.</pre><div class="public" id="var-applicative-law1"><h3>applicative-law1</h3><h4 class="macro">macro</h4><div class="usage"><code>(applicative-law1 f x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the applicative functor x
satisfies the first applicative law:

(fapply (pure x f) x) =&gt; (fmap f x)
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L54">Source</a></div></div><div class="public" id="var-applicative-law2-identity"><h3>applicative-law2-identity</h3><h4 class="macro">macro</h4><div class="usage"><code>(applicative-law2-identity x)</code></div><pre class="doc">Generates a test that checks if the applicative functor x
satisfies the second applicative law:

(fapply (pure x identity) x) =&gt; x
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L65">Source</a></div></div><div class="public" id="var-applicative-law3-composition"><h3>applicative-law3-composition</h3><h4 class="macro">macro</h4><div class="usage"><code>(applicative-law3-composition u v x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the applicative functor x
satisfies the third applicative law:

(&lt;*&gt; (pure x (curry comp)) u v x)
=&gt; (fapply u (fapply v x))
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L76">Source</a></div></div><div class="public" id="var-applicative-law4-homomorphism"><h3>applicative-law4-homomorphism</h3><h4 class="macro">macro</h4><div class="usage"><code>(applicative-law4-homomorphism ap f x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the applicative functor x
satisfies the fourth applicative law:

(fapply (pure a f) (pure a x)) =&gt; (f x)
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L89">Source</a></div></div><div class="public" id="var-applicative-law5-interchange"><h3>applicative-law5-interchange</h3><h4 class="macro">macro</h4><div class="usage"><code>(applicative-law5-interchange ap f x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the applicative functor x
satisfies the fifth applicative law:

(fapply u (pure a y)) =&gt; (fapply (pure a fn(% y)) u)
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L101">Source</a></div></div><div class="public" id="var-check-eq"><h3>check-eq</h3><div class="usage"><code>(check-eq expected)</code><code>(check-eq expected actual)</code></div><pre class="doc">Midje checker that check for the equality of contents in contexts such
as references and reducibles.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L9">Source</a></div></div><div class="public" id="var-data-structures-should-preserve-metadata"><h3>data-structures-should-preserve-metadata</h3><h4 class="macro">macro</h4><div class="usage"><code>(data-structures-should-preserve-metadata f1 f2 builder x y)</code></div><pre class="doc">Generates the tests that check whether the implementations
of functions defined in Fluokitten protocols that extend
Clojure core data structures preserve metadata.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L196">Source</a></div></div><div class="public" id="var-fapply-keeps-type"><h3>fapply-keeps-type</h3><h4 class="macro">macro</h4><div class="usage"><code>(fapply-keeps-type f x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the applicative functor x's
implementation of fapply keeps the type of x when the function
inside f is applied to its content.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L114">Source</a></div></div><div class="public" id="var-fmap-keeps-type"><h3>fmap-keeps-type</h3><h4 class="macro">macro</h4><div class="usage"><code>(fmap-keeps-type f x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the functor x's implementation of
fmap keeps the type of x when f is applied to its content.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L45">Source</a></div></div><div class="public" id="var-functor-law2"><h3>functor-law2</h3><h4 class="macro">macro</h4><div class="usage"><code>(functor-law2 f x)</code><code>(functor-law2 f g x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the functor x satisfies
the Second Functor Law:

(fmap (comp f g)) =&gt; (fmap f (fmap g))

or, when applied to a concrete functor:

(fmap (comp f g) x) =&gt; (fmap f (fmap g x))
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L29">Source</a></div></div><div class="public" id="var-magma-op-keeps-type"><h3>magma-op-keeps-type</h3><h4 class="macro">macro</h4><div class="usage"><code>(magma-op-keeps-type x y &amp; ys)</code></div><pre class="doc">Generates a test that checks if the operation op is closed on magma x.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L163">Source</a></div></div><div class="public" id="var-monad-law1-left-identity"><h3>monad-law1-left-identity</h3><h4 class="macro">macro</h4><div class="usage"><code>(monad-law1-left-identity m g x &amp; xs)</code></div><pre class="doc">Generates a test that checks if the monad x
satisfies the first monad law:

(bind (pure m x) f) =&gt; (g x)
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L125">Source</a></div></div><div class="public" id="var-monad-law2-right-identity"><h3>monad-law2-right-identity</h3><h4 class="macro">macro</h4><div class="usage"><code>(monad-law2-right-identity m)</code></div><pre class="doc">Generates a test that checks if the monad x
satisfies the secondmonad law:

(bind m (pure m)) =&gt; m
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L138">Source</a></div></div><div class="public" id="var-monad-law3-associativity"><h3>monad-law3-associativity</h3><h4 class="macro">macro</h4><div class="usage"><code>(monad-law3-associativity f g m &amp; ms)</code></div><pre class="doc">Generates a test that checks if the monad x
satisfies the third monad law:

(bind m (fn [x] (bind (f x) g)
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L149">Source</a></div></div><div class="public" id="var-monoid-identity-law"><h3>monoid-identity-law</h3><h4 class="macro">macro</h4><div class="usage"><code>(monoid-identity-law x &amp; xs)</code></div><pre class="doc">Generates a test that checks whether the Monoid implementation x
satisfies the monoid identity law, i.e. if identity element for op
exists:
   (op x (id x)) =&gt; x
   (op (id x) x) =&gt; x
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L183">Source</a></div></div><div class="public" id="var-semigroup-op-associativity"><h3>semigroup-op-associativity</h3><h4 class="macro">macro</h4><div class="usage"><code>(semigroup-op-associativity x y &amp; ys)</code></div><pre class="doc">Generates a test that checks if x and op form a semigroup,
i.e whether op is associative:

(op (op a b)) =&gt; (op a (op b c))
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/test.clj#L170">Source</a></div></div></div></body></html>