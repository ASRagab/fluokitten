<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.fluokitten.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Fluokitten 0.3.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="uncomplicate.fluokitten.core.html"><span>uncomplicate.fluokitten.core</span></a></li><li><a href="uncomplicate.fluokitten.jvm.html"><span>uncomplicate.fluokitten.jvm</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html"><span>uncomplicate.fluokitten.protocols</span></a></li><li><a href="uncomplicate.fluokitten.test.html"><span>uncomplicate.fluokitten.test</span></a></li><li><a href="uncomplicate.fluokitten.utils.html"><span>uncomplicate.fluokitten.utils</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="uncomplicate.fluokitten.core.html#var-%3C*%3E"><span>&lt;*&gt;</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-%3C%3D%3C"><span>&lt;=&lt;</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-%3E%3D%3E"><span>&gt;=&gt;</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-%3E%3E%3D"><span>&gt;&gt;=</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-bind"><span>bind</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-fapply"><span>fapply</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-fmap"><span>fmap</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-fold"><span>fold</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-foldmap"><span>foldmap</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-id"><span>id</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-join"><span>join</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-just"><span>just</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-just%3F"><span>just?</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-mdo"><span>mdo</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-op"><span>op</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-pure"><span>pure</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-return"><span>return</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-unit"><span>unit</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>uncomplicate.fluokitten.core documentation</h2><pre class="doc">Contains core Fluokitten categorical functions. This is the
namespace that you want to use or require in your projects that use
Fluokitten built-in functionality or the functionality of various other
libraries that implement Fluokitten protocols.
Intended use: use or require this namespace and other namespaces that
contain the implementations of the protocols, by default jvm.

---- Example:
(ns test
  (:use [uncomplicate.fluokitten core jvm]))</pre><div class="public" id="var-%3C*%3E"><h3>&lt;*&gt;</h3><div class="usage"><code>(&lt;*&gt; af)</code><code>(&lt;*&gt; af av)</code><code>(&lt;*&gt; af av &amp; avs)</code></div><pre class="doc">Performs a Haskell-style left-associative fapply
on its arguments. (&lt;*&gt; f g h) is equivalent to
(fapply (fapply f g) h). It always uses a two-argument fapply.

If only two arguments are supplied, it is equivalent to fapply.
When called with one argument, creates a function
that can accept the rest of the arguments and apply &lt;*&gt;.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L169">Source</a></div></div><div class="public" id="var-%3C%3D%3C"><h3>&lt;=&lt;</h3><div class="usage"><code>(&lt;=&lt; f)</code><code>(&lt;=&lt; f g)</code><code>(&lt;=&lt; f g &amp; hs)</code></div><pre class="doc">Composes monadic functions from right to left, in the reverse
order than &gt;=&gt;.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L327">Source</a></div></div><div class="public" id="var-%3E%3D%3E"><h3>&gt;=&gt;</h3><div class="usage"><code>(&gt;=&gt; f)</code><code>(&gt;=&gt; f g)</code><code>(&gt;=&gt; f g &amp; hs)</code></div><pre class="doc">Composes monadic functions from left to right, in the reverse
order from comp. The composed functions threads the calls
through &gt;&gt;=.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L306">Source</a></div></div><div class="public" id="var-%3E%3E%3D"><h3>&gt;&gt;=</h3><div class="usage"><code>(&gt;&gt;= monadic)</code><code>(&gt;&gt;= monadic f)</code><code>(&gt;&gt;= monadic f &amp; fs)</code></div><pre class="doc">Performs a Haskell-style left-associative bind
on its arguments. (&gt;&gt;= f g h) is equivalent to
(bind (bind f g) h). It always uses a two-argument bind.

If only two arguments are supplied, it is equivalent to bind.
When called with one argument, creates a function
that can accept the rest of the arguments and apply &gt;&gt;=.

bind maintains an implicit context, so &gt;&gt;= too supports
functions that depend on it, such are return and unit.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L286">Source</a></div></div><div class="public" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind f)</code><code>(bind monadic f)</code><code>(bind monadic monadic2 &amp; args)</code></div><pre class="doc">Takes a value inside the context of a monad (monadic value)
and a function f that takes a normal value (without the
context) and produces the result inside of a context
of the monadic type.

If called with more arguments, the last argument should be the
function f, and all previous arguments,
monadics will be used as arguments to the function
f. When called with one argument only, produces a function
with f fixed, so it just accepts monadic values and feeds
them to f.

For nested bind calls, there is a syntactic sugar, the
mdo macro.

bind can be also thought of as a function that combines
two computations into one large computation.

The behavior is largely constrained by the laws that should be
satisfied by any monad in regard to the behavior
or bind and pure (see the doc for
uncomplicate.fluokitten.protocols/Monad)

bind maintains an implicit context, and supports
functions that depend on it, such are return and unit.

Some common Clojure constructs that are Monads:
- persistent collections
- reducibles
- nil
- atoms, refs

---- Example with collections:
(bind [1 2 3] (comp list inc))
=&gt; [2 3 4]

---- Example with atoms:
(bind (atom 1) (comp atom inc))
=&gt; #&lt;Atom: 2&gt;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L234">Source</a></div></div><div class="public" id="var-fapply"><h3>fapply</h3><div class="usage"><code>(fapply af)</code><code>(fapply af av)</code><code>(fapply af av &amp; avs)</code></div><pre class="doc">Applies the function(s) inside af's context to the value(s)
inside av's context while preserving the context. Both contexts
should be of the same (or compatible) type, and the type of
the resulting context is determined by av's type.
af and af stand for &quot;applicative functor function&quot;
and &quot;applicative functor value&quot;.

Returns an applicative functor instance consisting of
the result of applying the function(s) inside af's context
to the value(s) inside the av's context. Vararg version
applies the function(s) inside af to the value(s)
provided by the avs' contexts. If called with only one argument,
lifts av so it can be applied to an applicative functor,
i.e creates a new function that can reach inside
the applicative functor's context and return the result
of applying the original context af.

fapply can be thought of as fmap that, instead of
plain function f receives one or many functions inside
the context af, extracts those functions from the context
and applies them to the values inside the context av.

The behavior is largely constrained by the laws that should be
satisfied by any applicative functor in regard to the behavior
or fapply and pure (see the doc for
uncomplicate.fluokitten.protocols/Applicative)

Some common Clojure constructs that are Applicative functors:
- persistent collections
- reducibles
- nil
- atoms, refs

---- Example 1: Clojure collections are applicative functors

(fapply [inc dec] [1 2 3])
=&gt; [2 3 4 0 1 2]

---- Example 2: atoms are applicative functors
(fapply (atom inc) (atom 1))
=&gt; 2
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L118">Source</a></div></div><div class="public" id="var-fmap"><h3>fmap</h3><div class="usage"><code>(fmap f functor)</code><code>(fmap f)</code><code>(fmap f functor &amp; functors)</code></div><pre class="doc">Applies a function f to the value(s) inside functor's context
while preserving the context. More about Functors can be found
in the doc for uncomplicate.fluokitten.protocols/Functor.

Returns a functor instance consisting of the result of applying f
to the value(s) inside the functor's context. Vararg version applies
f to value(s) provided by the functors' contexts. If called with only
one argument, lifts function f so it can be applied to functor,
i.e creates a new function that can reach inside the functor's
context and return the result of applying the original function f.

fmap can be thought of in two ways:
1. As a function that takes a function f and functor and then maps
   the function over the functor value. In this sense, it is similar
   to ubiquitous map function, with the difference that fmap works
   on any Functor instance and it preserves the context type (while
   map always converts its source to a sequence).
2. As a function that takes a function f so it can operate on functor
   values instead on plain values.

Function f should work on plain values without regard to the functor.
Functor must be an extension of Functor protocol and MUST satisfy
the functor laws
(see the doc for uncomplicate.fluokitten.protocols/Functor)

Some common Clojure constructs that are Functors:
- persistent collections
- reducibles
- functions
- nil
- atoms, refs
- strings
- keywords
- all Objects. (fmap f o) equals (f o) if nothing more specific has
  been defined for object's type

---- Example 1: Clojure collections are functors

(fmap str [1 2 3])
=&gt; [&quot;1&quot; &quot;2&quot; &quot;3&quot;]

Since clojure vector is a functor, it represents a context for its
elements. Function inc works on the elements of the vector, and
does not know anything about the vector itself. The result is a
vector of transformed elements.

---- Example 2: Clojure functions are functors

((fmap str +) 1 2 3)
=&gt; &quot;6&quot;

In this example, + is a context for its arguments. fmapping str
function over + functor (which is also a function), we get another
function that applies string to an argument, but with the context of
incrementing preserved.

---- Example 3: lifting a function
((fmap str) [1 2 3])
=&gt; [&quot;1&quot; &quot;2&quot; &quot;3&quot;]
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L17">Source</a></div></div><div class="public" id="var-fold"><h3>fold</h3><div class="usage"><code>(fold foldable)</code></div><pre class="doc">Folds all the contents of a foldable context by either
getting the single element or if there are more than one
elements in the context by combining them all in the one
aggregate value. How exactly these elements
are combined depends on the actual context. Collections,
that are often used as contexts, require that the elements
are monoids, so they can be easily combined using op.

Some common Clojure constructs that are Foldable:
- persistent collections
- reducibles
- nil
- atoms, refs
- all objects are foldable in a sense that
  (fold o) =&gt; o if there is no specific implementation

Some common Clojure constructs that are Monoids:
- persistent collections
- reducibles
- functions
- nil
- strings
- keywords
- numbers

---- Example: vector is foldable, while a set of real
numbers form a monoid with a binary operation + and identity
element 0. Thus,
(fold [1 2 3])
=&gt; 6
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L389">Source</a></div></div><div class="public" id="var-foldmap"><h3>foldmap</h3><div class="usage"><code>(foldmap f)</code><code>(foldmap f foldable)</code></div><pre class="doc">Folds the contest of a foldable context by applying
function f on each of its elements to produce a monoid
and then uses the operation op of that monoid to combine
the elements into a single aggregate value.
See the doc for fold, the only difference is that foldmap
can fold foldables that contain elements that are not
monoids, by using function f to transform them to monoids
before folding.

If called with only one argument, f, creates a function
that can fold a foldable that contains non-monoid values
by first using f to convert them to monoids.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L424">Source</a></div></div><div class="public" id="var-id"><h3>id</h3><div class="usage"><code>(id x)</code></div><pre class="doc">Returns the identity element of the monoid that x is
an element of.

---- Example 1: numbers
(id 3)
=&gt; 0

---- Example 2: strings
(id &quot;something&quot;)
=&gt; &quot;&quot;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L468">Source</a></div></div><div class="public" id="var-join"><h3>join</h3><div class="usage"><code>(join monadic)</code></div><pre class="doc">Flattens multiple monads nested in monadic into a single
flat monad that contains ordinary, non-monadic value.

---- Example with collections:
(join [[1 2] [3 4]])
=&gt; [1 2 3 4]

---- Example with atoms:
(join (atom (atom (atom 1))))
=&gt; #&lt;Atom: 1&gt;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L186">Source</a></div></div><div class="public" id="var-just"><h3>just</h3><div class="usage"></div><pre class="doc">Creates the context of Maybe monad and puts
the supplied value in it.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L483">Source</a></div></div><div class="public" id="var-just%3F"><h3>just?</h3><div class="usage"><code>(just? x)</code></div><pre class="doc">Checks whether x is an instance of the type Just .
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L488">Source</a></div></div><div class="public" id="var-mdo"><h3>mdo</h3><h4 class="macro">macro</h4><div class="usage"><code>(mdo bindings body)</code></div><pre class="doc">A syntactic sugar for gluing together chained bind calls.
The structure of mdo is similar to the structure of let.

bindings should be a vector of symbol - expression pairs
in the form [sym1 exp1 sym2 exp2 ...].
while the body should be an expression that uses these
symbols. Body is not wrapped in an implicit do block, so
if multiple forms are needed in the block, they have to
be explicitly wrapped with do.

If the bindings vector is empty, there are no bindings and
no bind function calls, mdo simply evaluates body in that
case.

(mdo [x some-monadic-value
      y some-other-monadic-value]
  some-expression)

expands to:

(bind some-monadic-value
      (fn [x]
        (bind some-other-monadic-value
              (fn [y]
                some-expression))))))

bind maintains an implicit context, so mdo too supports
functions that depend on it, such are return and unit.

---- Example:
(mdo [a [1 2]
      b [4 5]
      c [7]]
  (return (* a b c)))

=&gt; [28 35 56 70]
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L339">Source</a></div></div><div class="public" id="var-op"><h3>op</h3><div class="usage"><code>(op x y)</code><code>(op x y &amp; ys)</code></div><pre class="doc">Applies the monoid operation op determined by the type
of monoids x and y. Since op is closed on that monoid,
the result is also in the same monoid and can be further
combined by op with other elemens of the same monoid.

The vararg version is equivalent with (op (op x y) z),
but the actual algorithm for a given monoid depends
on the implementation. For example, (+ 1 2 3) is used
for numbers instead of (+ (1 2) 3)

---- Example 1: numbers as monoids
(op 1 2 3)
=&gt; 6

---- Example 2: strings ar monoids
(op &quot;some&quot; &quot;thing&quot;)
=&gt; &quot;something&quot;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L444">Source</a></div></div><div class="public" id="var-pure"><h3>pure</h3><div class="usage"><code>(pure applicative)</code><code>(pure applicative x)</code></div><pre class="doc">Takes any value x and wraps it in a minimal, default, context
of the same type as the context of the applicative value.

If called with only one argument, creates a pure function that
can wrap any value into a specific default context determined
by applicative.

The behavior is largely constrained by the laws that should be
satisfied by any applicative functor in regard to the behavior
or fapply and pure (see the doc for
uncomplicate.fluokitten.protocols/Applicative)

Has context-agnostic versions that take the applicative context
implicitly from the environment: return and unit.

---- Example 1: putting a number in a pure vector context
(pure [] 1)
=&gt; [1]

---- Example 2: a number in a pure curried function context:
((pure curried 1) 17)
=&gt; 1
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L89">Source</a></div></div><div class="public" id="var-return"><h3>return</h3><div class="usage"><code>(return x)</code></div><pre class="doc">A monad-agnostic version of pure, it is equivalent to
(pure &lt;current context&gt;). Valid only inside
a context-aware *time-dependent* dynamic scope.
Otherwise, an IllegalArgumentException will be thrown
complaining that there is no implementation found for
class clojure.lang.Var$Unbound.
The context is available inside the execution of bind
method (and the methods and macros that use it internaly,
such as &gt;&gt;= mdo), or inside the with-context macro.
Also equivalent to the unit function.

---- Example 1:
(defn f [x] (return (inc x)))
(bind [1 2 3] f)
=&gt; [2 3 4]
(bind (just 1) f)
=&gt; 2

---- Example 2:
(f 1)
=&gt; IllegalArgumentException
(with-context []
  (f 1))
=&gt; [1]
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L201">Source</a></div></div><div class="public" id="var-unit"><h3>unit</h3><div class="usage"></div><pre class="doc">The equivalent of the return method.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L230">Source</a></div></div></div></body></html>