<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.fluokitten.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Fluokitten 0.2.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="uncomplicate.fluokitten.core.html"><span>uncomplicate.fluokitten.core</span></a></li><li><a href="uncomplicate.fluokitten.jvm.html"><span>uncomplicate.fluokitten.jvm</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html"><span>uncomplicate.fluokitten.protocols</span></a></li><li><a href="uncomplicate.fluokitten.test.html"><span>uncomplicate.fluokitten.test</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="uncomplicate.fluokitten.core.html#var-%3C*%3E"><span>&lt;*&gt;</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-%3E%3E%3D"><span>&gt;&gt;=</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-bind"><span>bind</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-fapply"><span>fapply</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-fmap"><span>fmap</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-fold"><span>fold</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-foldmap"><span>foldmap</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-id"><span>id</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-join"><span>join</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-just"><span>just</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-op"><span>op</span></a></li><li><a href="uncomplicate.fluokitten.core.html#var-pure"><span>pure</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>uncomplicate.fluokitten.core documentation</h2><pre class="doc"></pre><div class="public" id="var-%3C*%3E"><h3>&lt;*&gt;</h3><div class="usage"><code>(&lt;*&gt; af)</code><code>(&lt;*&gt; af av)</code><code>(&lt;*&gt; af av &amp; avs)</code></div><pre class="doc">Performs a Haskell-style left-associative fapply
on its arguments. (&lt;*&gt; f g h) is equivalent to
(fapply (fapply f g) h). It always uses a two-argument fapply.

If only two arguments are supplied, it is equivalent to fapply.
When called with one argument, creates a function
that can accept the rest of the arguments and apply &lt;*&gt;.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L154">Source</a></div></div><div class="public" id="var-%3E%3E%3D"><h3>&gt;&gt;=</h3><div class="usage"><code>(&gt;&gt;= monadic)</code><code>(&gt;&gt;= monadic f)</code><code>(&gt;&gt;= monadic f &amp; fs)</code></div><pre class="doc">Performs a Haskell-style left-associative bind
on its arguments. (&gt;&gt;= f g h) is equivalent to
(bind (bind f g) h). It always uses a two-argument bind.

If only two arguments are supplied, it is equivalent to bind.
When called with one argument, creates a function
that can accept the rest of the arguments and apply &gt;&gt;=.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L231">Source</a></div></div><div class="public" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind f)</code><code>(bind monadic f)</code><code>(bind monadic monadic2 &amp; args)</code></div><pre class="doc">Takes a value inside the context of a monad (monadic value)
and a function f that takes a normal value (without the
context) and produces the result inside of a context
of the monadic type.

If called with more arguments, the last argument should be the
function f, and all previous arguments,
monadics will be used as arguments to the function
f. When called with one argument only, produces a function
with f fixed, so it just accepts monadic values and feeds
them to f.

bind can be also thought of as a function that combines
two computations into one large computation.

The behavior is largely constrained by the laws that should be
satisfied by any monad in regard to the behavior
or bind and pure (see the doc for
uncomplicate.fluokitten.protocols/Monad)

Some common Clojure constructs that are Monads:
- persistent collections
- reducibles
- nil
- atoms, refs

---- Example with collections:
(bind [1 2 3] (comp list inc))
=&gt; [2 3 4]

---- Example with atoms:
(bind (atom 1) (comp atom inc))
=&gt; #&lt;Atom: 2&gt;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L186">Source</a></div></div><div class="public" id="var-fapply"><h3>fapply</h3><div class="usage"><code>(fapply af)</code><code>(fapply af av)</code><code>(fapply af av &amp; avs)</code></div><pre class="doc">Applies the function(s) inside af's context to the value(s)
inside av's context while preserving the context. Both contexts
should be of the same (or compatible) type, and the type of
the resulting context is determined by av's type.
af and af stand for &quot;applicative functor function&quot;
and &quot;applicative functor value&quot;.

Returns an applicative functor instance consisting of
the result of applying the function(s) inside af's context
to the value(s) inside the av's context. Vararg version
applies the function(s) inside af to the value(s)
provided by the avs' contexts. If called with only one argument,
lifts av so it can be applied to an applicative functor,
i.e creates a new function that can reach inside
the applicative functor's context and return the result
of applying the original context af.

fapply can be thought of as fmap that, instead of
plain function f receives one or many functions inside
the context af, extracts those functions from the context
and applies them to the values inside the context av.

The behavior is largely constrained by the laws that should be
satisfied by any applicative functor in regard to the behavior
or fapply and pure (see the doc for
uncomplicate.fluokitten.protocols/Applicative)

Some common Clojure constructs that are Applicative functors:
- persistent collections
- reducibles
- nil
- atoms, refs

---- Example 1: Clojure collections are applicative functors

(fapply [inc dec] [1 2 3])
=&gt; [2 3 4 0 1 2]

---- Example 2: atoms are applicative functors
(fapply (atom inc) (atom 1))
=&gt; 2
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L103">Source</a></div></div><div class="public" id="var-fmap"><h3>fmap</h3><div class="usage"><code>(fmap f functor)</code><code>(fmap f)</code><code>(fmap f functor &amp; functors)</code></div><pre class="doc">Applies a function f to the value(s) inside functor's context
while preserving the context. More about Functors can be found
in the doc for uncomplicate.fluokitten.protocols/Functor.

Returns a functor instance consisting of the result of applying f
to the value(s) inside the functor's context. Vararg version applies
f to value(s) provided by the functors' contexts. If called with only
one argument, lifts function f so it can be applied to functor,
i.e creates a new function that can reach inside the functor's
context and return the result of applying the original function f.

fmap can be thought of in two ways:
1. As a function that takes a function f and functor and then maps
   the function over the functor value. In this sense, it is similar
   to ubiquitous map function, with the difference that fmap works
   on any Functor instance and it preserves the context type (while
   map always converts its source to a sequence).
2. As a function that takes a function f so it can operate on functor
   values instead on plain values.

Function f should work on plain values without regard to the functor.
Functor must be an extension of Functor protocol and MUST satisfy
the functor laws
(see the doc for uncomplicate.fluokitten.protocols/Functor)

Some common Clojure constructs that are Functors:
- persistent collections
- reducibles
- functions
- nil
- atoms, refs
- strings
- keywords
- all Objects. (fmap f o) equals (f o) if nothing more specific has
  been defined for object's type

---- Example 1: Clojure collections are functors

(fmap str [1 2 3])
=&gt; [&quot;1&quot; &quot;2&quot; &quot;3&quot;]

Since clojure vector is a functor, it represents a context for its
elements. Function inc works on the elements of the vector, and
does not know anything about the vector itself. The result is a
vector of transformed elements.

---- Example 2: Clojure functions are functors

((fmap str +) 1 2 3)
=&gt; &quot;6&quot;

In this example, + is a context for its arguments. fmapping str
function over + functor (which is also a function), we get another
function that applies string to an argument, but with the context of
incrementing preserved.

---- Example 3: lifting a function
((fmap str) [1 2 3])
=&gt; [&quot;1&quot; &quot;2&quot; &quot;3&quot;]
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L5">Source</a></div></div><div class="public" id="var-fold"><h3>fold</h3><div class="usage"><code>(fold foldable)</code></div><pre class="doc">Folds all the contents of a foldable context by either
getting the single element or if there are more than one
elements in the context by combining them all in the one
aggregate value. How exactly these elements
are combined depends on the actual context. Collections,
that are often used as contexts, require that the elements
are monoids, so they can be easily combined using op.

Some common Clojure constructs that are Foldable:
- persistent collections
- reducibles
- nil
- atoms, refs
- all objects are foldable in a sense that
  (fold o) =&gt; o if there is no specific implementation

Some common Clojure constructs that are Monoids:
- persistent collections
- reducibles
- functions
- nil
- strings
- keywords
- numbers

---- Example: vector is foldable, while a set of real
numbers form a monoid with a binary operation + and identity
element 0. Thus,
(fold [1 2 3])
=&gt; 6
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L248">Source</a></div></div><div class="public" id="var-foldmap"><h3>foldmap</h3><div class="usage"><code>(foldmap f)</code><code>(foldmap f foldable)</code></div><pre class="doc">Folds the contest of a foldable context by applying
function f on each of its elements to produce a monoid
and then uses the operation op of that monoid to combine
the elements into a single aggregate value.
See the doc for fold, the only difference is that foldmap
can fold foldables that contain elements that are not
monoids, by using function f to transform them to monoids
before folding.

If called with only one argument, f, creates a function
that can fold a foldable that contains non-monoid values
by first using f to convert them to monoids.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L283">Source</a></div></div><div class="public" id="var-id"><h3>id</h3><div class="usage"><code>(id x)</code></div><pre class="doc">Returns the identity element of the monoid that x is
an element of.

---- Example 1: numbers
(id 3)
=&gt; 0

---- Example 2: strings
(id &quot;something&quot;)
=&gt; &quot;&quot;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L327">Source</a></div></div><div class="public" id="var-join"><h3>join</h3><div class="usage"><code>(join monadic)</code></div><pre class="doc">Flattens multiple monads nested in monadic into a single
flat monad that contains ordinary, non-monadic value.

---- Example with collections:
(join [[1 2] [3 4]])
=&gt; [1 2 3 4]

---- Example with atoms:
(join (atom (atom (atom 1))))
=&gt; #&lt;Atom: 1&gt;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L171">Source</a></div></div><div class="public" id="var-just"><h3>just</h3><div class="usage"></div><pre class="doc">Creates the context of Maybe monad and puts
the supplied value in it.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L342">Source</a></div></div><div class="public" id="var-op"><h3>op</h3><div class="usage"><code>(op x y)</code><code>(op x y &amp; ys)</code></div><pre class="doc">Applies the monoid operation op determined by the type
of monoids x and y. Since op is closed on that monoid,
the result is also in the same monoid and can be further
combined by op with other elemens of the same monoid.

The vararg version is equivalent with (op (op x y) z),
but the actual algorithm for a given monoid depends
on the implementation. For example, (+ 1 2 3) is used
for numbers instead of (+ (1 2) 3)

---- Example 1: numbers as monoids
(op 1 2 3)
=&gt; 6

---- Example 2: strings ar monoids
(op &quot;some&quot; &quot;thing&quot;)
=&gt; &quot;something&quot;
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L303">Source</a></div></div><div class="public" id="var-pure"><h3>pure</h3><div class="usage"><code>(pure applicative)</code><code>(pure applicative x)</code></div><pre class="doc">Takes any value x and wraps it in a minimal, default, context
of the same type as the context of the applicative value.

If called with only one argument, creates a pure function that
can wrap any value into a specific default context determined
by applicative.

The behavior is largely constrained by the laws that should be
satisfied by any applicative functor in regard to the behavior
or fapply and pure (see the doc for
uncomplicate.fluokitten.protocols/Applicative)

---- Example 1: putting a number in a pure vector context
(pure [] 1)
=&gt; [1]

---- Example 2: a number in a pure curried function context:
((pure curried 1) 17)
=&gt; 1
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/core.clj#L77">Source</a></div></div></div></body></html>