<!DOCTYPE html>
<html><head><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>uncomplicate.fluokitten.protocols documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Fluokitten 0.2.0 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="uncomplicate.fluokitten.core.html"><span>uncomplicate.fluokitten.core</span></a></li><li><a href="uncomplicate.fluokitten.jvm.html"><span>uncomplicate.fluokitten.jvm</span></a></li><li class="current"><a href="uncomplicate.fluokitten.protocols.html"><span>uncomplicate.fluokitten.protocols</span></a></li><li><a href="uncomplicate.fluokitten.test.html"><span>uncomplicate.fluokitten.test</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="uncomplicate.fluokitten.protocols.html#var-Applicative"><span>Applicative</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-Foldable"><span>Foldable</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-Functor"><span>Functor</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-Magma"><span>Magma</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-Monad"><span>Monad</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-Monoid"><span>Monoid</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-bind"><span>bind</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-fapply"><span>fapply</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-fmap"><span>fmap</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-fold"><span>fold</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-foldmap"><span>foldmap</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-join"><span>join</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-op"><span>op</span></a></li><li><a href="uncomplicate.fluokitten.protocols.html#var-pure"><span>pure</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>uncomplicate.fluokitten.protocols documentation</h2><pre class="doc"></pre><div class="public" id="var-Applicative"><h3>Applicative</h3><div class="usage"></div><pre class="doc">Applicative (applicative functor) is an abstraction for a
context (box, container, computation) along with the abiliity
to apply function(s) contained in the same type of context to
all the things inside that context. Every Applicative should
also implement Functor, although it can not be automatically
forced by Clojure protocols.

A typical example is a clojure sequence, wich is a container
of elements, with the ability to apply all the functions
contained in another sequence to each of the elements,
wich produces a new sequence of elements transformed by
all the functions.

You create a new applicative functor type by extending
the Applicative protocol and implementing pure and fapply
methods, while observing applicative functor laws:

1. (fapply (pure x f) x) =&gt; (fmap f x)

2. Identity Law: (fapply (pure x identity) x) =&gt; x

3. Composition Law:
   (fapply (fapply (fapply (pure x (curry comp)) u) v) x)
   =&gt; (fapply u (fapply v x))

4. Homomorphism Law: (fapply (pure a f) (pure a x)) =&gt; (f x)

5. Interchange Law:
   (fapply u (pure a y)) =&gt; (fapply (pure a #(% y)) u)

Fluokitten's test library contains macros that generate
tests for applicative functor laws.

The pure and fapply methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/protocols.clj#L51">Source</a></div></div><div class="public" id="var-Foldable"><h3>Foldable</h3><div class="usage"></div><pre class="doc">Foldable is an abstraction for a context (box, container,
computation) along with the ability to extract the summary
value of its contents. Foldable implementations  do not
have to implement other categorical protocols, although
it is conveinent to view fold as an oposite of the function
pure: pure puts values in minimal context, while fold
gets the value outside of the context. With some Foldables,
(such as Atom) context contains a single value that can be
accessed by fold, while some (such as PersistentColection)
contain many values, so they can only extract it as some
summary value.

You create a new foldable type by extending the Foldable
protocol and implementing fold and foldmap methods.

The fold and foldmap methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/protocols.clj#L208">Source</a></div></div><div class="public" id="var-Functor"><h3>Functor</h3><div class="usage"></div><pre class="doc">Functor is an abstraction for a context (box, container,
computation) along with the abiliity to apply a function
to all the things inside that context. A typical example
is a clojure sequence, wich is a container of elements,
with the ability to apply a function to each of the elements,
wich produces a new sequence of elements transformed by
that function.

You create a new functor type by extending the Functor
protocol and implementing fmap method, while observing
functor laws:

1. (fmap identity) =&gt; identity ,
   that is (fmap identity x) =&gt; (identity x)

2. (fmap (comp f g)) =&gt; (fmap f (fmap g))
   or, when applied to a concrete functor
   (fmap (comp f g) x) =&gt; (fmap f (fmap g x))

(please note that core's fmap that has a different
order of arguments has been used in these examples,
as it would be used by clients)

Fluokitten's test library contains macros that generate
tests for functor laws.

The fmap method is not intended to be used directly by
the caller, although you should use it directly from
the implementation of this protocol if needed from
other methods.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/protocols.clj#L6">Source</a></div></div><div class="public" id="var-Magma"><h3>Magma</h3><div class="usage"></div><pre class="doc">Magma is an abstraction of elements that have an operation op,
which combines its arguments into an element of the same
type (op is closed on the set of all objects that have that type).
If the operation op is also associative, then that magma
is also a semigroup.

You create a new magma type by extending the Magma protocol
and implementing op method while observing the following laws:

1. op is closed: (instance? (type x) (op x y)) =&gt; true

2. associativity (only for semigroups):
   (op (op a b)) =&gt; (op a (op b c))

Fluokitten's test library contains macros that generate
tests for checking whether op is closed and/or associative.

The op method is not intended to be used
directly by the caller, although you should use it directly
from the implementation of this protocol if needed from
other methods.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/protocols.clj#L157">Source</a></div></div><div class="public" id="var-Monad"><h3>Monad</h3><div class="usage"></div><pre class="doc">Monad is an abstraction for a context (box, container,
computation) along with the ability to apply a function
that accepts the value without the context and produces
the result in a context. The resulting context may be
different than the starting context. While the main idea
with functors and applicatives is modifying the values
inside the context, monad is more oriented towards modifying
the context.  Every Monad should also implement
Applicative and Functor protocols, although this can not be
automatically forced by Clojure compiler.

You create a new monad type by extending the Monad protocol
and implementing bind and join methods, while observing
monad laws:

1. Left Identity Law: (bind (pure m x) f) =&gt; (g x)

2. Right Identity Law: (bind m (pure m)) =&gt; m

3. Associativity Law:
   (bind (bind m f) g) =&gt; (bind m (fn [x] (bind (f x) g)

Fluokitten's test library contains macros that generate
tests for monad laws.

The bind and join methods are not intended to be used
directly by the caller, although you should use them directly
from the implementation of this protocol if needed from
other methods.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/protocols.clj#L110">Source</a></div></div><div class="public" id="var-Monoid"><h3>Monoid</h3><div class="usage"></div><pre class="doc">Monoid is an abstraction of elements that are magmas whose
op has an identity element. (op x (id x)) =&gt; x. Every Monoid
should also implement Magma protocols, although this can not be
automatically forced by Clojure compiler.

You create a new monoid type by extending the Monoid protocol
and implementing id method, while observing monoid law:

1. identity element for op exists:
   (op x (id x)) =&gt; x
   (op (id x) x) =&gt; x

Fluokitten's test library contains macros that generate
monoid tests.

The id method is not intended to be used
directly by the caller, although you should use it directly
from the implementation of this protocol if needed from
other methods.
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/src/uncomplicate/fluokitten/protocols.clj#L185">Source</a></div></div><div class="public" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind mv g)</code><code>(bind mv g mvs)</code></div><pre class="doc">Applies the function g to the value(s) inside mv's context.
Function g produces the result inside with the context,
in contrast to fmap where function g is expect to produce
normal values. If more monadic values are supplied in a
sequence mvs, uses them as arguments for a vararg g.
This method is intended to be used by fluokitten core's
bind, not directly by clients. The third argument, mvs,
contains a sequence of all additional arguments, normally
supplied by core bind's varargs (protocol methods do not
support varargs).
</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div><div class="public" id="var-fapply"><h3>fapply</h3><div class="usage"><code>(fapply ag av)</code><code>(fapply ag av avs)</code></div><pre class="doc">Applies the function(s) inside ag's context to the value(s)
inside av's context while preserving the context. Both contexts
should be of the same (or compatible) type, and the type of
the resulting context is determined by av's type.
If more applicative functor values are supplied in a
sequence avs, uses them as arguments for vararg
function(s) inside the context ag.
This method is intended to be used by fluokitten core's
fapply, not directly by clients. The third argument, avs,
contains a sequence of all additional arguments, normally
supplied by core fapply's varargs (protocol methods do not
support varargs).</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div><div class="public" id="var-fmap"><h3>fmap</h3><div class="usage"><code>(fmap fv g)</code><code>(fmap fv g fvs)</code></div><pre class="doc">Applies function g to the value(s) inside the context
of the functor fv. The result is a functor of the same
type as fv. If more functor values are supplied in a
sequence fvs, uses them as arguments for a vararg g.
This method is intended to be used by fluokitten core's
fmap, not directly by clients. The first two arguments
are reversed compared to core's fmap because protocol's
polymorphism is based on java-based dispatch. The third
parameter, fvs, contains a sequence of all additional
arguments, normally supplied by core fmap's varargs
(protocol methods do not support varargs).</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div><div class="public" id="var-fold"><h3>fold</h3><div class="usage"><code>(fold foldable)</code></div><pre class="doc">Extracts the value(s) from the context and returns it
as one single value. Contexts that contain multiple values
typically require that values are Monoids and use op
to combine them.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div><div class="public" id="var-foldmap"><h3>foldmap</h3><div class="usage"><code>(foldmap foldable g)</code></div><pre class="doc">Similar to fold, but before returning the sole value
from the context or combining multiple values into
a summary, applies the function g to transform it
(to a Monoid if needed).</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div><div class="public" id="var-join"><h3>join</h3><div class="usage"><code>(join mv)</code></div><pre class="doc">Flattens multiple monads nested in monadic into a single
flat monad that contains ordinary, non-monadic value.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div><div class="public" id="var-op"><h3>op</h3><div class="usage"><code>(op x y)</code><code>(op x y ys)</code></div><pre class="doc">Operation that combines elements x and y into an element
of the same type. If more elements are supplied in
a sequence ys, combines them all.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div><div class="public" id="var-pure"><h3>pure</h3><div class="usage"><code>(pure av v)</code></div><pre class="doc">Takes any context av and any value a, and puts
the value a in the same type of context. a should be put
in the most minimal context possible that has appropriate
type. av is needed only for proper dispatching and is
not changed in any way.</pre><div class="src-link"><a href="http://github.com/uncomplicate/fluokitten/blob/master/#L">Source</a></div></div></div></body></html>